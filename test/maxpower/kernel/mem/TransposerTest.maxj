package maxpower.kernel.mem;

import static org.junit.Assert.assertArrayEquals;

import java.util.Random;

import org.junit.Test;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.managers.standard.SimulationManager;

public class TransposerTest {

	final static int NUM_RUNS = 5;

	final static int NUM_DATA_RUNS = 4;

	private static class TransposerTestKernel extends Kernel{

		public TransposerTestKernel(KernelParameters parameters, final int width, final int height,
				final int depth) {
			super(parameters);

			DFEVar input = io.input("input", dfeFloat(8, 24));

			io.output("output", dfeFloat(8, 24)) <==
				stream.offset(Transposer.transpose(input, width, height, depth, constant.var(true)),
						width * height * depth);
		}
	}

	@Test
	public void test2DTransposerWrapper() {
		long seed = System.currentTimeMillis();
		Random rng = new Random(seed);
		for (int i = 0; i < NUM_RUNS; i++) {
			final int width  = Math.abs(rng.nextInt()) % 32 + 1;
			final int height = Math.abs(rng.nextInt()) % 32 + 1;
			test2DTransposer(width, height, seed);
		}
	}

	@Test
	public void test3DTransposerWrapper() {
		long seed = System.currentTimeMillis();
		Random rng = new Random(seed);
		for (int i = 0; i < 1; i++) {
			final int width  = Math.abs(rng.nextInt()) % 32 + 1;
			final int height = Math.abs(rng.nextInt()) % 32 + 1;
			final int depth = Math.abs(rng.nextInt()) % 32 + 1;
			test3DTransposer(width, height, depth, seed);
		}
	}

	private void test2DTransposer(final int width, final int height, final long seed) {
		double input[]    = new double[NUM_DATA_RUNS * height * width];
		double actual[]   = new double[NUM_DATA_RUNS * height * width];
		double expected[] = new double[NUM_DATA_RUNS * height * width];

		for (int i = 0; i < NUM_DATA_RUNS; i++) {
			for (int j = 0; j < height; j++) {
				for (int k = 0; k < width; k++) {
					input[i * height * width + j * width + k] = j * height + k;
					expected[i * height * width + k * height + j] = j * height + k;
				}
			}
		}

		SimulationManager manager = new SimulationManager("Transposer2DTest");
		TransposerTestKernel kernel = new TransposerTestKernel(manager.makeKernelParameters(), width, 1, height);
		manager.setKernel(kernel);
		manager.build();
		manager.logInfo("Seed: %d, Width: %d, Height: %d", seed, width, height);

		manager.setKernelCycles(NUM_DATA_RUNS * height * width);
		manager.setInputData("input", input);
		manager.run();

		actual = manager.getOutputDataArray("output");

		/*System.out.println("Width: " + width + " Height: " + height);
		for (int i = 0; i < height; i++) {
			for (int j = 0; j < width; j++) {
				System.out.println("Is: " + actual[i * width + j] + " Expected " + expected[i * width + j]);
			}
		}*/
		assertArrayEquals("BitReverse", expected, actual, 0);
	}

	private void test3DTransposer(final int width, final int height, int depth, final long seed) {
		double input[]    = new double[NUM_DATA_RUNS * height * width *  depth];
		double actual[]   = new double[NUM_DATA_RUNS * height * width *  depth];
		double expected[] = new double[NUM_DATA_RUNS * height * width *  depth];

		for (int i = 0; i < NUM_DATA_RUNS; i++) {
			for (int j = 0; j < width; j++) {
				for (int k = 0; k < height; k++) {
					for (int l = 0; l < depth; l++) {
						input[i * height * width * depth + j * height * depth + k * depth + l] =
							j * height * depth + k * depth + l;
						expected[i * height * width * depth + j * height * depth + k * depth + l] =
							j + k * width + l * height * width;
					}
				}
			}
		}

		SimulationManager manager = new SimulationManager("Transposer3DTest");
		TransposerTestKernel kernel = new TransposerTestKernel(manager.makeKernelParameters(), width, height, depth);
		manager.setKernel(kernel);
		manager.build();
		manager.logInfo("Seed: %d, Width: %d, Height: %d", seed, width, height);

		manager.setKernelCycles(NUM_DATA_RUNS * height * width * depth);
		manager.setInputData("input", input);
		manager.run();

		actual = manager.getOutputDataArray("output");

		/*System.out.println("Width: " + width + " Height: " + height);
		for (int i = 0; i < width; i++) {
			for (int j = 0; j < height; j++) {
				for (int k = 0; k < depth; k++) {
					System.out.println("Is: " + actual[i * height * depth + j * depth + k] +
							" Expected " + expected[i * height * depth + j * depth + k]);
				}
			}
		}*/
		assertArrayEquals("BitReverse", expected, actual, 0);
	}
}