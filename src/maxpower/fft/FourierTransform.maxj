package maxpower.fft;

import java.util.ArrayList;
import java.util.List;

import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEComplex;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

/**
 * KernelLib for a mixed-radix implementation of a size 2^N.
 *
 * This factory uses cyclic addressing in order to process multiple inputs at
 * a time (number dependent on radix), and will output continuously (after an
 * offset to allow the first values go through all FFT stages). The input is
 * expected as for a radix-4 FFT, i.e. 4 values per cycle.
 *
 * Multiple parallel FFTs can performed from a single factory assuming they
 * are running in phase.
 *
 * @author Stephen Girdlestone
 */
public class FourierTransform {

	// Expose useful parameters
	public static final int NUM_FFT_PIPES = 4;

	/**
	 * Default constructor creating an {@link FourierTransform FFT factory}.
	 *
	 * @param kernel {@link KernelLib Kernel} object that uses the factory.
	 * @param twiddleType Generic {@link DFEType type} of real and imaginary
	 * values for the twiddle factors (Twiddle factors are generated between
	 * -1 and +1.
	 * @param N The size of the FFT (Must be a power of two or a power of
	 * 2 and be greater than 16).
	 */

	/**
	 * This method is a wrapper for transform(final List<DFEVector<DFEComplex>>).
	 * It calls functions to rearrange the input into the correct format, pass it into the
	 * other transform function, then rearrange the output.
	 *
	 * @param input contains stream of FFT inputs
	 * @param numFFTs indicates the number of simultaneous FFTs
	 * @return a DFEVector containing the FFT outputs.
	 */
	public static DFEVector<DFEComplex> transform(final int N, final DFEType twiddleType,
			final DFEVector<DFEComplex> input, int numFFTs) {
		final int fftSize = N;

		List<DFEVector<DFEComplex>> codedOutput =
			transform(N, twiddleType, true, encodeFftInput(input, numFFTs, NUM_FFT_PIPES));
		return decodeFftOutput(codedOutput, numFFTs, NUM_FFT_PIPES, fftSize);
	}

	/**
	 * This method implements the FFT solver. The decimation used is a
	 * decimation in frequency as the twiddle factor is multiplied after the
	 * linear combination of the inputs.
	 *
	 * The input is expected in the order ready for the radix-2 butterfly,
	 * e.g. values 0/128/256/384 then 1/129/257/385 and so on. The output will
	 * be in bit-reversed order.
	 *
	 * @param input {@link List} containing complex streams of FFT inputs.
	 * @return {@link List} containing complex streams of FFT outputs
	 */
	public static List<DFEVector<DFEComplex>> transform(final int N, final DFEType twiddleType,
			final boolean doBitReverse, final List<DFEVector<DFEComplex>> input) {
		KernelLib owner = input[0].getKernel();

		owner.stream.suppressOffsetVectorWarnings();

		final int fftSize = N;
		if (fftSize < 16 || !MathUtils.isPowerOf2(fftSize)) {
			throw new RuntimeException("4 pipe FFT currently only supports sizes that are 2^N for N > 4.");
		}
		final int exponent = MathUtils.bitsToAddress(N);
		final int radix4phases = exponent / 2;
		final int radix2phases = exponent % 2;

		int depth = fftSize;
		final List<DFEVector<DFEComplex>> rdx4input;
		rdx4input = FftBuffer.applyInputBuffer(input, fftSize);

		List<DFEVector<DFEComplex>> fftOut;
		if (radix2phases == 1) {
			fftOut = ButterflyLib.applyButterfly(fftSize, 0, rdx4input, 2, twiddleType);
			fftOut = FftBuffer.applyMixedRadixBuffer(fftOut, fftSize);
			depth /= 2;
		} else if (radix2phases == 0) {
			fftOut = rdx4input;
		} else {
			throw new RuntimeException("Number of radix 2 stages must be either 0 or 1 (negative is impossible, and 2 should be a radix 4 stage).");
		}

		for (int phase = 1; phase <= radix4phases; phase++) {
			fftOut = ButterflyLib.applyButterfly(fftSize, phase, fftOut, 4, twiddleType);

			if(phase < radix4phases) {
				fftOut = FftBuffer.applyInterStageBuffer(fftOut, depth, 4);
				depth /= 4;
			}
		}

		if (doBitReverse) {
			fftOut = FftBuffer.applyBitReverseBuffer(fftOut, fftSize);
		}

		return fftOut;
	}

	private static List<DFEVector<DFEComplex>> encodeFftInput(DFEVector<DFEComplex> input,
			int nFFT, int nPipes) {
		List<DFEVector<DFEComplex>> list = new ArrayList<DFEVector<DFEComplex>>();
		DFEVectorType<DFEComplex> fftType = new DFEVectorType<DFEComplex>(input[0].getType(), nFFT);

		int bitsPerPipe = fftType.getTotalBits();
		for(int i = 0; i < nPipes; i++){
			list.add(fftType.unpack(input.pack().slice(i*bitsPerPipe, bitsPerPipe)));
		}
		return list;
	}

	private static DFEVector<DFEComplex> decodeFftOutput(List<DFEVector<DFEComplex>> input,
			int nFFT, int nPipes, int fftSize) {
		DFEVector<DFEComplex> result = new DFEVectorType<DFEComplex>(input.get(0).getType().getContainedType(),
				nPipes*nFFT).newInstance(input[0].getKernel());

		for (int i = 0; i < 4; i++) {
			for (int j = 0; j < nFFT; j++){
				result.connect(i*nFFT+j, input[i][j]);
			}
		}
		return result;
	}
}
