package maxpower.fft;

import java.util.List;

import maxpower.fft.buffer.FftBuffer;
import maxpower.fft.buffer.MixedRadixBuffer;
import maxpower.fft.buffer.Radix4InputBuffer;

import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEComplex;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

/**
 * KernelLib for a mixed-radix implementation of a size 2^N.
 *
 * This factory uses cyclic addressing in order to process multiple inputs at
 * a time (number dependent on radix), and will output continuously (after an
 * offset to allow the first values go through all FFT stages). The input is
 * expected as for a radix-4 FFT, i.e. 4 values per cycle.
 *
 * Multiple parallel FFTs can performed from a single factory assuming they
 * are running in phase.
 *
 * @author Stephen Girdlestone
 */
public class FftFactory4pipes extends KernelLib {

	// Expose useful parameters
	public static final int NUM_FFT_PIPES	= 4;

	/** Number of butterfly phases of FFT. */
	private final int m_radix4phases;
	private final int m_radix2phases;
	/** Exponent 2 representing the number of input data points (N). */
	private final int m_exponent;
	private final int m_fftSize;
	/** {@link DFEType Type} of twiddle factors. */
	private final DFEType m_twiddleType;

	/** {@link TwiddleFactory Twiddle factory}. */
	private final TwiddleFactory m_twiddleFactory;
	/** {@link List} of twiddle factors for Radix-2 stage. */
	private final List<DFEComplex> m_r2Twiddles;
	/** @link MixedRadixBuffer Mixed-radix buffer}. */
	private final MixedRadixBuffer m_mixedBuffer;

	private final Radix4InputBuffer  m_r4InputBuffer;


	/**
	 * Default constructor creating an {@link FftFactory4pipes FFT factory}.
	 *
	 * @param kernel {@link KernelLib Kernel} object that uses the factory.
	 * @param twiddleType Generic {@link DFEType type} of real and imaginary
	 * values for the twiddle factors (Twiddle factors are generated between
	 * -1 and +1.
	 * @param N The size of the FFT (Must be a power of two or a power of
	 * 2 and be greater than 32).
	 */
	public FftFactory4pipes(KernelLib kernel, final DFEType twiddleType, int N) {
		super(kernel);

		stream.suppressOffsetVectorWarnings();

		m_fftSize = N;
		if (!validFftSize(m_fftSize)) {
			throw new RuntimeException("4 pipe FFT currently only supports sizes that are 2^N for N > 5.");
		}
		m_r4InputBuffer  = new Radix4InputBuffer(this, m_fftSize);
		m_exponent       = MathUtils.bitsToAddress(N);

		m_radix4phases = m_exponent / 2;
		m_radix2phases = m_exponent % 2;
		m_twiddleType = twiddleType;

		m_twiddleFactory = new TwiddleFactory(Radix.RADIX_4, m_radix4phases, m_twiddleType, constant.var(true));

		/*
		 * Enable write all the time we are processing data to make sure all
		 * buffer phases get completed. Note that we may be processing data
		 * when neither input not output is enabled.
		 */
		if (m_radix2phases == 1) {
			m_mixedBuffer    = new MixedRadixBuffer(m_exponent, constant.var(true));
			m_r2Twiddles	 = m_twiddleFactory.r2dualTwiddles(m_mixedBuffer.getDataCount());
		} else {
			m_mixedBuffer    = null;
			m_r2Twiddles     = null;
		}
	}

	/**
	 * This method is a wrapper for transform(final List<DFEVector<DFEComplex>>).
	 * It calls functions to rearrange the input into the correct format, pass it into the
	 * other transform function, then rearrange the output.
	 *
	 * @param input contains stream of FFT inputs
	 * @param numFFTs indicates the number of simultaneous FFTs
	 * @return a DFEVector containing the FFT outputs.
	 */
	public DFEVector<DFEComplex> transform(final DFEVector<DFEComplex> input, int numFFTs) {
		List<DFEVector<DFEComplex>> codedOutput = transform(Encoder.encodeFftInput(input, numFFTs, 4));
		return Encoder.decodeFftOutput(this, codedOutput, numFFTs, 4);
	}

	/**
	 * This method implements the FFT solver. The decimation used is a
	 * decimation in frequency as the twiddle factor is multiplied after the
	 * linear combination of the inputs.
	 *
	 * The input is expected in the order ready for the radix-2 butterfly,
	 * e.g. values 0/128/256/384 then 1/129/257/385 and so on. The output will
	 * be in bit-reversed order.
	 *
	 * @param input {@link List} containing complex streams of FFT inputs.
	 * @return {@link List} containing complex streams of FFT outputs
	 */
	public List<DFEVector<DFEComplex>> transform(final List<DFEVector<DFEComplex>> input) {
		int depth = m_fftSize;
		final List<DFEVector<DFEComplex>> rdx4input;
		rdx4input = m_r4InputBuffer.transpose(input);

		List<DFEVector<DFEComplex>> fftOut;
		if (m_radix2phases == 1) {
			fftOut = ButterflyLib.createButterfly(rdx4input, m_r2Twiddles, Radix.RADIX_2);
			fftOut = m_mixedBuffer.transpose(fftOut);
			depth /= 2;
		} else if (m_radix2phases == 0) {
			fftOut = rdx4input;
		} else {
			throw new RuntimeException("Number of radix 2 stages must be either 0 or 1 (negative is impossible, and 2 should be a radix 4 stage).");
		}

		for (int phase = 1; phase <= m_radix4phases; phase++) {
			final List<DFEComplex> twiddles = m_twiddleFactory.getTwiddles(phase);

			fftOut = ButterflyLib.createButterfly(fftOut, twiddles, Radix.RADIX_4);

			if(phase < m_radix4phases) {
				fftOut = FftBuffer.buffer(fftOut, depth, Radix.RADIX_4.getRadix(), Radix.RADIX_4.getRadix());
				depth /= 4;
			}
		}

		return fftOut;
	}



	private boolean validFftSize(int fftSize) {
		int minFftSize = 32;
		if (fftSize < minFftSize) {
			return false;
		}
		if (fftSize == minFftSize) {
			return true;
		}
		if (fftSize % 2 == 0) {
			return validFftSize(fftSize / 2);
		} else {
			return false;
		}
	}

	public DFEVar acceptingInput() {
		return constant.var(true);
	}
}
