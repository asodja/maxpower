package maxpower.fft;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEFix;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEComplex;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEComplexType;
import com.maxeler.maxcompiler.v2.utils.Bits;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

/**
 * Provides twiddle factors for an FFT. Twiddle factors are calculated for
 * each FFT butterfly phase and stored in ROMs, which are then referenced as
 * the FFT progresses. Twiddle factories can be shared across parallel FFTs,
 * assuming they work in phase.
 *
 * @author simon
 */
public class TwiddleFactory extends KernelLib {
	/** Disable {@link HWVar#watch(String) watches} by default. */
	private static final boolean DEBUG_WATCHES = false;

	/** {@link Radix Radix} of FFT. */
	private final Radix m_radixType;
	/** Exponent of the radix representing the number of data points (N). */
	private final int m_exponent;
	/** {@link DFEType Type} of twiddle factors. */
	private final DFEType m_twiddleType;

	/** Radix of FFT. */
	private final int m_radix;
	/** Binary shift to convert exponent of radix to binary. */
	private final int m_radixShift;
	/** Bit width of input (2^(N_BITS) = N). */
	private final int m_noBits;
	/** Number of inputs. */
	private final int m_N;
	/** Number of FFT butterfly phases. */
	private final int m_phases;
	/** Number of twiddle factors for butterfly (i.e. radix - 1). */
	private final int m_noTwiddles;
	/** {@link DFEComplexType Complex type} for twiddle factors. */
	private final DFEComplexType m_twiddleComplexType;

	/** Map to hold twiddle factors for each phase. */
	private final Map<Integer, Twiddles> m_twiddles;
	/** Raw bits of calculated twiddle factors for ROM. */
	private final Bits[] m_twiddleFactorsBits;

	/**
	 * Constructor for creating a {@link TwiddleFactory twiddle factory}.
	 *
	 * @param kernel {@link KernelLib Kernel} object that uses the factory.
	 * @param radixType {@link Radix Radix} of FFT.
	 * @param exponent Exponent of radix.
	 * @param twiddleType {@link DFEType Type} of twiddle factors to generate.
	 */
	public TwiddleFactory(final Radix radixType, final int exponent,
			final DFEType twiddleType, KernelLib owner) {
		super(owner);
		m_radixType = radixType;
		m_twiddleType = twiddleType;
		m_exponent = exponent;

		m_radix = m_radixType.getRadix();
		m_radixShift = m_radixType.getBinaryShift();
		m_noBits = m_exponent * m_radixShift;
		m_N = 1 << m_noBits;
		m_phases = m_exponent;
		m_noTwiddles = m_radix - 1;
		m_twiddleComplexType = new DFEComplexType(m_twiddleType);

		m_twiddleFactorsBits = calcTwiddleFactorsValues();
		m_twiddles = createTwiddleROMsForAllPhases();
	}

	/**
	 * Get the twiddle factors for a given FFT butterfly phase.
	 *
	 * @param forPhase FFT phase to get twiddles for.
	 * @return {@link DFEComplex Complex} twiddle factors for butterfly.
	 */
	public List<DFEComplex> getTwiddles(final int forPhase) {
		return m_twiddles.get(forPhase).getTwiddles();
	}

	/**
	 * Generate the twiddles for the dual radix-2 butterfly stage.
	 *
	 * @param dataCount Current dataset count.
	 * @return {@link List} of twiddle factors.
	 */
	public List<DFEComplex> r2dualTwiddles(final DFEVar dataCount) {
		final KernelLib owner = dataCount.getKernel();
		final List<DFEComplex> twiddles = new ArrayList<DFEComplex>(FftFactory4pipes.NUM_FFT_PIPES);

		final int fftSize = (int) Math.pow(2, m_exponent * 2 + 1);
		final int numTwiddles = fftSize / 4;
		final DFEType addressType = KernelLib.dfeUInt(MathUtils.bitsToAddress(numTwiddles));
		final Bits[] twiddleFactors = new Bits[numTwiddles];
		final DFEComplexType twiddleType = new DFEComplexType(m_twiddleType);
		final double precision;
		if (m_twiddleType instanceof DFEFix) {
			precision = 1.0 / (1 << ((DFEFix) m_twiddleType).getFractionBits());
		} else {
			precision = 0.0;
		}

		for (int i = 0; i < numTwiddles; i++) {
			final double angle = -i * 2 * Math.PI / fftSize;
			final double real  = Math.cos(angle);
			final double img   = Math.sin(angle);

			final double realTw = (Math.abs(real) > precision) ? real : 0.0;
			final double imgTw  = (Math.abs(img)  > precision) ? img  : 0.0;

			final Bits twiddle = twiddleType.encodeConstant(realTw, imgTw);
			twiddleFactors[i] = twiddle;
		}

		final DFEComplex twiddle = owner.mem.rom(dataCount.cast(addressType), twiddleType,
				twiddleFactors);

		twiddles.add(twiddle);
		DFEComplex secondTwiddle = DFEComplexType.newInstance(owner, twiddle.getImaginary(),
				-twiddle.getReal());
		twiddles.add(secondTwiddle);

		return twiddles;
	}

	/**
	 * Creates ROMs containing the {@link DFEComplex complex} twiddle factors
	 * for each phase.
	 *
	 * @return {@link Map} of twiddle ROMs by phase.
	 */
	private Map<Integer, Twiddles> createTwiddleROMsForAllPhases() {
		final Map<Integer, Twiddles> twiddleRoms =
				new HashMap<Integer, Twiddles>(m_phases);
		// Phase 0 doesn't have twiddles; butterfly starts from phase 1
		for (int phase = 1; phase <= m_phases; phase++) {
			final Twiddles twiddles = new Twiddles(phase);
			twiddleRoms.put(phase, twiddles);
		}
		return twiddleRoms;
	}

	/**
	 * Calculates the raw {@link DFEComplex complex} twiddle factors based on
	 * the FFT size N.
	 *
	 * @return Array of raw twiddle factor {@link Bits bits}.
	 */
	private Bits[] calcTwiddleFactorsValues() {
		// Calculate twiddles for a full circle, with resolution 1/N.
		final Bits[] twiddleFactorsBits = new Bits[m_N];
		final double twiddleTypePrecision;
		if (m_twiddleType instanceof DFEFix) {
			twiddleTypePrecision = 1.0/ (1<<((DFEFix)m_twiddleType).getFractionBits());
		} else {
			twiddleTypePrecision = 0.0;
		}

		for (int i = 0; i < m_N; i++) {
			final double angle = -i * 2 * Math.PI / m_N;
			final double real  = Math.cos(angle);
			final double img   = Math.sin(angle);

			final double realTw = (Math.abs(real) > twiddleTypePrecision) ? real : 0.0;
			final double imgTw  = (Math.abs(img)  > twiddleTypePrecision) ? img  : 0.0;

			// store twiddle factor as Java complex and HW Bits
			twiddleFactorsBits[i] = m_twiddleComplexType.encodeConstant(realTw, imgTw);
		}
		return twiddleFactorsBits;
	}

	/**
	 * Twiddle class representing all twiddles for a single phase.
	 *
	 * @author simon
	 */
	private class Twiddles {
		/** FFT phase. */
		private final int m_phase;
		/** Bit width of twiddle factor index (i.e. 2^T_BITS = T). */
		private final int m_tBits;
		/** Number of twiddle factors. */
		private final int m_T;
		/** Ratio used to index raw twiddle factors as phase progresses. */
		private final int m_tRatioShift;

		/** List of twiddles. */
		private final List<DFEComplex> m_twiddles;

		/**
		 * Constructor to create twiddle factors.
		 *
		 * @param phase FFT butterfly phase.
		 * @param startTwiddling Indication of whether to start twiddling.
		 */
		public Twiddles(final int phase) {
			m_phase = phase;

			m_tBits = (m_phases - m_phase) * m_radixShift;
			m_T = 1 << m_tBits;
			m_tRatioShift = (m_phase - 1) * m_radixShift;

			m_twiddles = calcTwiddles();
		}

		/**
		 * Get the twiddle factors.
		 *
		 * @return List of twiddle factors.
		 */
		public List<DFEComplex> getTwiddles() {
			return m_twiddles;
		}

		/**
		 * Calculate the twiddle factors for the required FFT butterfly phase
		 * and store in ROMs, which are then referenced as the FFT progresses.
		 *
		 * @return {@link List} of twiddle factors.
		 */
		private List<DFEComplex> calcTwiddles() {
			final List<DFEComplex> twiddles =
					new ArrayList<DFEComplex>(m_noTwiddles);

			if (m_phase == m_phases) {
				// In the last phase, all twiddle factors are (1,0).
				final DFEComplex realOnlyTwiddle = DFEComplexType.newInstance(
						TwiddleFactory.this, constant.var(1), constant.var(0))
						.cast(m_twiddleComplexType);
				for (int i = 0; i < m_noTwiddles; i++) {
					twiddles.add(realOnlyTwiddle);
				}
			} else {
				// Set up the subset of data for ROMs according to the phase.
				final Bits[][] twiddleBits = new Bits[m_noTwiddles][m_T];
				for (int j = 0; j < m_noTwiddles; j++) {
					final int increment = (j + 1) << m_tRatioShift;
					for (int i = 0; i < m_T; i++) {
						final int index = i * increment;
						twiddleBits[j][i] = m_twiddleFactorsBits[index];
					}
				}
				// Create the address counter.
				final CounterChain chain =
						control.count.makeCounterChainMoreBits();
				final DFEVar dataCount = chain.addCounter(m_T, 1);

				// Create the phase ROMs.
				for (int i = 0; i < m_noTwiddles; i++) {
					final DFEComplex twiddle =
							mem.rom(dataCount.cast(dfeUInt(m_tBits)), m_twiddleComplexType, twiddleBits[i]);
					twiddles.add(twiddle);
				}

				if (DEBUG_WATCHES) {
					for (int i = 0; i < m_noTwiddles; i++) {
						final DFEComplex twOut = twiddles.get(i);
						twOut.simWatch("ph" + m_phase + "tw" + (i + 1));
					}
				}
			}
			return twiddles;
		}
	}
}
