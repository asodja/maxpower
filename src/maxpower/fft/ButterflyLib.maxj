package maxpower.fft;

import java.util.ArrayList;
import java.util.List;

import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.Optimization;
import com.maxeler.maxcompiler.v2.kernelcompiler.op_management.MathOps;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEFix;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEComplex;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEComplexType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;

/**
 * This is a collection of all the butterfly functions for radix-4 and dual radix-2 FFTs.
 *
 * @author stephen
 *
 */
public class ButterflyLib {

	/**
	 * If radix is 2: perform a dual radix-2 butterfly on the inputs, applying twiddle
	 * factors to the results. The input is expected such that the first
	 * butterfly is on values 0 and 2, the second on values 1 and 3. Results
	 * are output in the same order.
	 * Else do a normal radix-4 butterfly
	 *
	 * @param input Input values.
	 * @return Output values.
	 */
	public static List<DFEVector<DFEComplex>> createButterfly(List<DFEVector<DFEComplex>> input,
			List<DFEComplex> twiddles, Radix radix) {

		KernelLib k = input[0].getKernel();
		DFEType type = (DFEType) ((DFEComplexType)input[0].getType().getContainedType()).getRealType();
		// Optimise if using fixed types.
		if (type instanceof DFEFix) {
			final int typeOffset = ((DFEFix)type).getOffset();
			k.optimization.pushFixOpMode(
					Optimization.bitSizeLargest(),
					Optimization.offsetExact(typeOffset),
					MathOps.ADD_SUB, MathOps.MUL);
		}

		final List<DFEVector<DFEComplex>> output = new ArrayList<DFEVector<DFEComplex>>(4);

		if (radix.getRadix() == 4) {
			DFEVector<DFEComplex> a = input[0] + input[2];
			DFEVector<DFEComplex> b = input[1] + input[3];
			DFEVector<DFEComplex> c = input[0] - input[2];
			DFEVector<DFEComplex> d = input[1] - input[3];

			// bit reversing the output, hence using twiddle factor 1 first then 0,
			// then 2
			DFEVector<DFEComplex> jd = d * k.constant.cplx(type, 0, 1);

			output.add( a + b);
			output.add((a - b)  * twiddles[1]);
			output.add((c - jd) * twiddles[0]);
			output.add((c + jd) * twiddles[2]);
		} else { // dual radix 2
			output.add((input[0] + input[2]));
			output.add((input[1] + input[3]));
			output.add((input[0] - input[2]) * twiddles[0]);
			output.add((input[1] - input[3]) * twiddles[1]);
		}

		if (type instanceof DFEFix) {
			k.optimization.popFixOpMode(MathOps.ADD_SUB, MathOps.MUL);
		}

		return output;
	}
}
