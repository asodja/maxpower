package maxpower.fft;

import java.util.ArrayList;
import java.util.List;

import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.Optimization;
import com.maxeler.maxcompiler.v2.kernelcompiler.op_management.MathOps;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEFix;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEComplex;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEComplexType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;

/**
 * This is a collection of all the butterfly functions for different radix FFTs.
 *
 * WARNING: Note that the radix 5 FFT is currently special, in that it is assumed to be feeding
 * in to a radix 4 FFT, so is assumed to need to output 4 pipes rather than 5.
 * The result of this is that it has a separate function for applying the twiddles. This is done
 * so that applying the twiddles can be done in 4 pipes, saving both DSPs (for the multiplies)
 * and BRAMs (for the twiddle ROM).
 * This also means that the twiddle ROM needs to be 4 pipes wide and store the transpose of the
 * normal twiddle factors.
 * This is an optimisation for the most common use case (a 5*2^n FFT). The more general case is
 * not yet implemented.
 *
 * @author stephen
 *
 */
public class ButterflyLib {

	public static List<DFEVector<DFEComplex>> radix4butterfly(List<DFEVector<DFEComplex>> input, List<DFEComplex> twiddles) {
		if (input.size() != 4) {
			throw new RuntimeException("radix4butterfly expects 4 pipes of input.");
		}
		if (twiddles.size() != 3) {
			throw new RuntimeException("radix4butterfly requires 3 twiddle factors.");
		}
		KernelLib k = input[0].getKernel();
		DFEType type = (DFEType) ((DFEComplexType)input[0].getType().getContainedType()).getRealType();
		// Optimise if using fixed types.
		if (type instanceof DFEFix) {
			final int typeOffset = ((DFEFix)type).getOffset();
			k.optimization.pushFixOpMode(
					Optimization.bitSizeLargest(),
					Optimization.offsetExact(typeOffset),
					MathOps.ADD_SUB, MathOps.MUL);
		}

		DFEVector<DFEComplex> a = input[0] + input[2];
		DFEVector<DFEComplex> b = input[1] + input[3];
		DFEVector<DFEComplex> c = input[0] - input[2];
		DFEVector<DFEComplex> d = input[1] - input[3];

		// bit reversing the output, hence using twiddle factor 1 first then 0,
		// then 2
		DFEVector<DFEComplex> jd = d * k.constant.cplx(type, 0, 1);

		List<DFEVector<DFEComplex>> output = new ArrayList<DFEVector<DFEComplex>>(4);
		output.add( a + b);
		output.add((a - b)  * twiddles[1]);
		output.add((c - jd) * twiddles[0]);
		output.add((c + jd) * twiddles[2]);

		if (type instanceof DFEFix) {
			k.optimization.popFixOpMode(MathOps.ADD_SUB, MathOps.MUL);
		}

		return output;
	}

	/**
	 * Perform a dual radix-2 butterfly on the inputs, applying twiddle
	 * factors to the results. The input is expected such that the first
	 * butterfly is on values 0 and 2, the second on values 1 and 3. Results
	 * are output in the same order.
	 *
	 * @param input Input values.
	 * @return Output values.
	 */
	public static List<DFEVector<DFEComplex>> radix2DualButterfly(final List<DFEVector<DFEComplex>> input, List<DFEComplex> twiddles) {
		if (input.size() != 4) {
			throw new RuntimeException("radix2DualButterfly expects 4 pipes of input.");
		}
		if (twiddles.size() != 2) {
			throw new RuntimeException("radix2DualButterfly requires 2 twiddle factors.");
		}
		KernelLib k = input[0].getKernel();
		DFEType type = (DFEType) ((DFEComplexType)input[0].getType().getContainedType()).getRealType();
		// Optimise if using fixed types.
		if (type instanceof DFEFix) {
			final int typeOffset = ((DFEFix)type).getOffset();
			k.optimization.pushFixOpMode(
					Optimization.bitSizeLargest(),
					Optimization.offsetExact(typeOffset),
					MathOps.ADD_SUB, MathOps.MUL);
		}
		final List<DFEVector<DFEComplex>> output = new ArrayList<DFEVector<DFEComplex>>(4);
		output.add((input[0] + input[2]));
		output.add((input[1] + input[3]));
		output.add((input[0] - input[2]) * twiddles[0]);
		output.add((input[1] - input[3]) * twiddles[1]);

		if (type instanceof DFEFix) {
			k.optimization.popFixOpMode(
					MathOps.ADD_SUB, MathOps.MUL);
		}

		return output;
	}
}
