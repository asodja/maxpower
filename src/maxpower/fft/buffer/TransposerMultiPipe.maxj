package maxpower.fft.buffer;

import java.util.ArrayList;
import java.util.List;

import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.Optimization;
import com.maxeler.maxcompiler.v2.kernelcompiler.op_management.MathOps;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.KernelMath;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Mem.RamWriteMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEComplex;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEComplexType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

/**
 * Use single buffer to transpose 2D matrices.
 */
public class TransposerMultiPipe extends KernelLib {

	private final DFEVector<DFEComplex> m_output;

	/**
	 * A multi-pipe implementation of a transpose for 2D Matrices with complex numbers.
	 *
	 * @param in {@DFEVector} of inputs
	 * @param width fast dimension
	 * @param height slow dimension
	 */
	public TransposerMultiPipe(KernelLib owner, DFEVector<DFEComplex> in, int width, int height) {
		this(owner, in, width, height, false);
	}
	public TransposerMultiPipe(KernelLib owner, DFEVector<DFEComplex> in, int width, int height, boolean bitReverse) {
		super(owner);
		int nPipes 	= in.getSize();
		int ramSize = width*height/nPipes;
		int nBy4	= width/4;

		DFEComplexType					dataType			= in[0].getType();
		DFEVectorType<DFEComplex>		vectorType			= new DFEVectorType<DFEComplex>(dataType, nPipes);
		DFEVectorType<DFEComplex>		bufferOutVectorType = new DFEVectorType<DFEComplex>(dataType, nPipes);
		DFEVectorType<DFEVar>			addressType			= new DFEVectorType<DFEVar>(dfeUInt(MathUtils.bitsToAddress(ramSize)), nPipes);
		DFEVector<DFEVar>				ramReadAddress		= addressType.newInstance(this);


		CounterChain counterChainRow = control.count.makeCounterChain();
		CounterChain counterChainCol = control.count.makeCounterChain();
		DFEVar whichBuffer 	= counterChainRow.addCounter(2, 1);
		DFEVar row_j		= counterChainRow.addCounter(height, 1);
		DFEVar row_i		= counterChainRow.addCounter(width/nPipes, 1);

		DFEVar col_j;

		if (bitReverse){
			col_j = bitReverse(counterChainCol.addCounter(width, 1), width);

		}
		else{
			col_j = counterChainCol.addCounter(width, 1);
		}


		DFEVar col_i		= counterChainCol.addCounter(height, nPipes);
		DFEVar shift_write	= KernelMath.modulo(row_j, nPipes);
		DFEVar shift_read	= KernelMath.modulo(col_j, nPipes);


		optimization.pushFixOpMode(Optimization.bitSizeExact(MathUtils.bitsToAddress(ramSize)), Optimization.offsetExact(0), MathOps.ALL);
		DFEVar ramWriteAddress = row_j * nBy4 + row_i.cast(row_j.getType());

		for(int j = 0; j < nPipes; j++){
			ramReadAddress[j] <== (col_i +j) * nBy4 + (col_j >> 2);
		}

		optimization.popFixOpMode(MathOps.ALL);


		DFEVector<DFEComplex>	inputRotated		= in.rotateElementsLeft(shift_write.cast(dfeUInt(2)));
		DFEVector<DFEVar>		readAddrRotated		= ramReadAddress.rotateElementsLeft(shift_read);

		if(bitReverse){
			//double buffer if bit reverse.
			List<List<Memory<DFEComplex>>>	buffers				= new ArrayList<List<Memory<DFEComplex>>>();
			List<DFEVector<DFEComplex>>		bufferOutput		= new ArrayList<DFEVector<DFEComplex>>();
			for(int i = 0; i < 2; i++){

				buffers.add(i, new ArrayList<Memory<DFEComplex>>());
				bufferOutput.add(bufferOutVectorType.newInstance(this));

				for(int j = 0; j < nPipes; j++){

					buffers[i].add(j, mem.alloc(vectorType.getContainedType(), ramSize));
					bufferOutput[i][j] <== buffers[i][j].port(
							whichBuffer===i? ramWriteAddress : readAddrRotated[j],
								inputRotated[j], whichBuffer===i, RamWriteMode.READ_FIRST);


				}
			}

			DFEVector<DFEComplex> colValues_shifted	= whichBuffer ? bufferOutput[0] : bufferOutput[1];
			DFEVector<DFEComplex> dataOut			= colValues_shifted.rotateElementsRight(shift_read);


			m_output = stream.offset(dataOut, ramSize);
		}
		else{


			List<Memory<DFEComplex>> 	buffers			= new ArrayList<Memory<DFEComplex>>();
			DFEVector<DFEComplex>		bufferOutput	= bufferOutVectorType.newInstance(this);

				for(int j = 0; j < nPipes; j++){

					buffers.add(j, mem.alloc(vectorType.getContainedType(), ramSize));
					bufferOutput[j] <== buffers[j].port(
							whichBuffer? readAddrRotated[j] : ramWriteAddress ,
								inputRotated[j], constant.var(true), RamWriteMode.READ_FIRST);


				}

			DFEVector<DFEComplex> dataOut = bufferOutput.rotateElementsRight(shift_read);

			m_output = stream.offset(dataOut, ramSize);

		}


	}

	public DFEVector<DFEComplex> getOutput() {
		return m_output;
	}

	/*
	 *  Reverse the bits between [0, log2(N)).  So if N is 512:
	 *  0b000011101 -> 0b101110000
	 *  0b110000001 -> 0b100000011
	 */
	DFEVar bitReverse(DFEVar x, int length){
		Double logN = Math.log(length)/Math.log(2.);
		DFEVar xr	= constant.var(x.getType(), 0);
		for(int i = 0; i < logN.intValue(); i++){
			xr	= xr << 1;
			xr	= xr | (x & 1);
			x	= x >> 1;
		}
		return xr;
	}
}
