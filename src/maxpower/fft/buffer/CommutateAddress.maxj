package maxpower.fft.buffer;

import java.util.ArrayList;
import java.util.List;

import maxpower.fft.Radix;
import maxpower.fft.buffer.CyclicAddressFactory.CyclicAddress;

import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.KernelMath;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.Reductions;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Counter;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

/**
 * {@link CyclicAddress Cyclic address} implementation for commutating.
 *
 * @author simon
 */
public class CommutateAddress extends KernelLib implements CyclicAddressFactory.CyclicAddress {
	/** Radix of FFT. */
	private final int m_radix;
	/** Binary shift to convert exponent of radix to binary. */
	private final int m_radixShift;
	/** Exponent of FFT radix (i.e. N = radix ^ exponent). */
	private final int m_exponent;
	/** Number of buffers. */
	private final int m_noBuffers;
	/** Number of bits to represent FFT values (i.e. N = 1 << N_BITS). */
	private final int m_noBits;
	/** Number of bits to represent data sets. */
	private final int m_noDataSetBits;
	/** Number of data sets. */
	private final int m_noDataSets;
	/** Number of values per buffer. */
	private final int m_valuesPerBuffer;
	/** Number of cycles - always 2 for commutating. */
	private final static int NO_CYCLES = 2;
	/** Enable processing. */
	private final DFEVar m_enable;
	/** {@link DFEType HW type} for addresses. */
	private final DFEType m_addressType;

	/** List containing address pattern. */
	private final List<DFEVar> m_address;
	/** Boolean indication of buffer inversion. */
	private final DFEVar m_invertBuffer;
	/** Boolean indication of when output is available. */
	private final DFEVar m_outputAvailable;
	/** Which buffer we are using for writing. */
	private final DFEVar m_writeBuffer;
	/** Size of each buffer. */
	private final int m_bufferSize;
	/** Set to true if you want all addresses to start from cycle 0. */
	private final boolean m_offsetAddresses;

	public CommutateAddress(final Radix radixType,
			final int exponent, final int noBuffers, final DFEVar startAddressing) {
		this(radixType, exponent, noBuffers, startAddressing, true);
	}
	/**
	 * Constructor to create {@link CommutateAddress commutating address}.
	 *
	 * @param kernel {@link KernelLib Kernel} object.
	 * @param radixType {@link Radix Radix} of FFT.
	 * @param exponent Exponent of radix.
	 * @param noBuffers Number of RAM buffers to use (max 2 values per buffer
	 * 		with dual port RAM).
	 * @param startAddressing Indication of whether to start addressing.
	 */
	public CommutateAddress(final Radix radixType,
			final int exponent, final int noBuffers,
			final DFEVar startAddressing,
			final boolean offsetAddresses) {
		super(startAddressing.getKernel());
		m_radix = radixType.getRadix();
		m_radixShift = radixType.getBinaryShift();
		m_exponent = exponent;
		m_noBuffers = noBuffers;
		m_enable = Reductions.streamHold(constant.var(true), startAddressing);
		m_offsetAddresses = offsetAddresses;

		m_noBits = m_exponent * m_radixShift;
		m_noDataSetBits = m_noBits - m_radixShift;
		m_noDataSets = 1 << m_noDataSetBits;
		m_valuesPerBuffer = m_radix / m_noBuffers;
		m_bufferSize = m_valuesPerBuffer << m_noDataSetBits;
		m_addressType = dfeUInt(MathUtils.bitsToAddress(m_bufferSize));

		final CounterChain chain = control.count.makeCounterChainMoreBits(m_enable);
		final DFEVar cycleCount = chain.addCounter(NO_CYCLES, 1);
		final DFEVar dataCount = chain.addCounter(m_noDataSets, 1);

		if (PlatformUtils.isDoubleBufferingRequired(this)) {
			final Counter bufferCounter = control.count.makeCounter(
					control.count.makeParams(1)
							.withEnable(chain.getCurrentCounterWrap()));
			m_writeBuffer = bufferCounter.getCount() === 0;
		} else {
			m_writeBuffer = null;
		}

		m_address = calculateAddressPattern(dataCount, cycleCount);
		m_invertBuffer = calculateInvertPattern(dataCount);
		m_outputAvailable = calculateOuputAvailable(cycleCount);
	}

	@Override
	public List<DFEVar> getAddress() {
		return this.m_address;
	}

	@Override
	public DFEVar isBufferInverted() {
		return this.m_invertBuffer;
	}

	@Override
	public DFEVar isOutputAvailable() {
		return m_outputAvailable;
	}

	@Override
	public int getBufferSize() {
		return this.m_bufferSize;
	}

	@Override
	public DFEVar getWriteBuffer() {
		return m_writeBuffer;
	}

	@Override
	public boolean getOffsetAddresses() {
		return m_offsetAddresses;
	}

	/**
	 * Calculate the address pattern for the streams.
	 *
	 * @param dataCount Current data set count.
	 * @param cycleCount Current buffer cycle count.
	 * @return {@link List} of buffer addresses.
	 */
	private List<DFEVar> calculateAddressPattern(
			final DFEVar dataCount, final DFEVar cycleCount) {
		final List<DFEVar> addresses = new ArrayList<DFEVar>(m_radix);
		final DFEType valueType = dfeUInt(m_noBits);
		for (int i = 0; i < m_radix; i++) {
			// First calculate position in stream.
			final DFEVar position = dataCount.cast(valueType)
					+ (i << m_noDataSetBits);
			// Next cycle the buffer location if required.
			final DFEVar value = cycleCount.eq(0) ?
					position : cyclePosition(position);
			final DFEVar address;
			if (m_noBuffers > 1) {
				// Multiple buffers - work out where in the buffer it is.
				address = (value >> m_radixShift) * m_valuesPerBuffer
						+ KernelMath.modulo(value, m_valuesPerBuffer)
								.cast(valueType);
			} else {
				address = value;
			}
			addresses.add(address.cast(m_addressType));
		}
		return addresses;
	}

	/**
	 *  Calculate buffer inversion pattern.
	 *
	 * @param dataCount Current data set count.
	 * @return Indication of whether buffers should be inverted.
	 */
	private DFEVar calculateInvertPattern(final DFEVar dataCount) {
		final DFEVar invert;
		// Check we have enough buffers to need an inversion.
		if (m_noBuffers > 1) {
			final DFEVar radixCount =
					dataCount.slice(m_radixShift - 1).cast(dfeUInt(1));
			DFEVar inv = radixCount.eq(1);
			if (m_exponent > 2) {
				final DFEVar halfCount =
						dataCount.slice(m_noDataSetBits - 1).cast(dfeUInt(1));
				inv = halfCount.eq(1) ? ~inv : inv;
				if (m_exponent > 3) {
					// Need a further inversion within output data size.
					final DFEVar halfOutputCount =
							dataCount.slice(m_noDataSetBits - 1 - m_radixShift)
							.cast(dfeUInt(1));
					inv = halfOutputCount.eq(1) ? ~inv : inv;
				}
			}
			invert = inv;
		} else {
			invert = constant.var(false);
		}
		return invert;
	}

	/**
	 * Calculate whether output data is available. Output should be valid
	 * after one full buffer cycle.
	 *
	 * @param cycleCount Current buffer cycle count.
	 * @return Indication of whether output is valid.
	 */
	private DFEVar calculateOuputAvailable(final DFEVar cycleCount) {
		return Reductions.streamHold(constant.var(true), cycleCount.gt(0));
	}

	/**
	 * Cycle a position value by digit swapping the 2 most significant digits
	 * (the digit size being defined by the radix).
	 *
	 * @param position Position in stream to cycle.
	 * @return Cycled position value.
	 */
	private DFEVar cyclePosition(final DFEVar position) {
		final DFEType positionType = position.getType();
		final DFEType digitSwapType = dfeUInt(m_radixShift);
		final int swapBitStart = m_noBits - 2 * m_radixShift;

		final DFEVar digitSwap =
				position.slice(swapBitStart + m_radixShift, m_radixShift)
						.cast(digitSwapType).cast(positionType)
				| (position.slice(swapBitStart, m_radixShift)
						.cast(digitSwapType).cast(positionType)
						<< m_radixShift);
		final DFEVar newPosition;
		if (swapBitStart > 0) {
			newPosition =
				position.slice(0, swapBitStart)
						.cast(dfeUInt(swapBitStart)).cast(positionType)
				| (digitSwap << swapBitStart);
		} else {
			newPosition = digitSwap;
		}
		return newPosition;
	}
}
