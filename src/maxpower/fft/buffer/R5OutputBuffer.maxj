package maxpower.fft.buffer;

import java.util.ArrayList;
import java.util.List;

import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEComplex;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

public class R5OutputBuffer extends KernelLib {

	private static final int m_numPipes = 4;

	private final int   m_fftSize;
	private final DFEVar m_iSource;
	private final DFEVar m_addrW;
	private final DFEVar m_addrR;
	private final DFEVar m_readIdx;
	private final NonPowerTwoDepthMem memory;

	public R5OutputBuffer(KernelLib owner, int fftSize) {
		super(owner);
		memory = new NonPowerTwoDepthMem(this);
		m_fftSize = fftSize;

		int nextBufferSize = m_fftSize / (5 * m_numPipes);
		int indexBits = MathUtils.bitsToAddress(nextBufferSize);

		final DFEType addrType = dfeUInt(MathUtils.bitsToAddress(m_fftSize / m_numPipes * 2));
		final CounterChain chain = control.count.makeCounterChainMoreBits();
		final DFEVar sel = chain.addCounter(2, 1).cast(dfeBool());
		final DFEVar idx = chain.addCounter(nextBufferSize, 1);
		m_iSource       = chain.addCounter(5, 1);

		final DFEVar count = idx.cast(addrType) * 5 + m_iSource.cast(addrType);
		// TODO: find way to explain calculation of index
		final DFEVar index = (count.slice(indexBits, addrType.getTotalBits() - indexBits)
				# count.slice(0, 2) # count.slice(2, indexBits-2)).cast(addrType);

		m_addrW = (sel ? constant.var(addrType, m_fftSize / m_numPipes) : constant.var(addrType, 0))
					+ m_iSource.cast(addrType) * (m_fftSize / (5 * m_numPipes))
					+ idx.cast(addrType);
		m_addrR = (~sel ? constant.var(addrType, m_fftSize / m_numPipes) :
				constant.var(addrType, 0)) + index;
		m_readIdx = count.slice(0, 2).cast(dfeUInt(2));
	}

	public List<DFEVector<DFEComplex>> transposeOut(List<DFEVector<DFEComplex>> input) {
		if (input.size() != 5) {
			throw new RuntimeException("The radix 5 output buffer needs 5 inputs.");
		}

		final DFEVectorType<DFEComplex> inputType = input[0].getType();
		// Packing the data so that we can put it in RAMs as HWVars (KMultiPipes aren't allowed to go in a RAM)
		final List<DFEVar> packedInput = new ArrayList<DFEVar>(input.size());
		for (int i = 0; i < input.size(); i++) {
			packedInput.add(input[i].pack());
		}

		// Assign data to a vector of KArrays
		// TODO: describe delays
		final DFEVectorType<DFEVar> arrayType = new DFEVectorType<DFEVar>(packedInput[0].getType(), m_numPipes);
		final List<DFEVector<DFEVar>> inputs = new ArrayList<DFEVector<DFEVar>>(5);
		for (int i = 0; i < 5; i++) {
			final DFEVector<DFEVar> array = arrayType.newInstance(this);
			for (int j = 0; j < m_numPipes; j++) {
				array.connect(j, stream.offset(packedInput[i], j));
			}
			inputs.add(stream.offset(array, -i));
		}

		final DFEVector<DFEVar> dataW = control.mux(m_iSource, inputs);

		DFEVector<DFEVar> ramOutput = memory.simpleDualPortRam(dataW, m_addrR, m_addrW, m_fftSize / m_numPipes * 2);

		final List<DFEVector<DFEVar>> outArrays = new ArrayList<DFEVector<DFEVar>>(m_numPipes);
		for (int i = 0; i < m_numPipes; i++) {
			final DFEVector<DFEVar> array = arrayType.newInstance(this);
			for (int j = 0; j < m_numPipes; j++) {
				array[j].connect(stream.offset(ramOutput[i], j));
			}
			outArrays.add(stream.offset(array, -i));
		}
		DFEVector<DFEVar> outArray = stream.offset(control.mux(m_readIdx, outArrays), m_fftSize / m_numPipes);

		// Unpack data from HWVar back to KMultiPipe<KComplex> now that we have extracted them from the RAM
		final List<DFEVector<DFEComplex>> outputs = new ArrayList<DFEVector<DFEComplex>>(m_numPipes);
		for (int i = 0; i < m_numPipes; i++) {
			outputs.add(inputType.unpack(outArray[i]));
		}
		return outputs;
	}

}
