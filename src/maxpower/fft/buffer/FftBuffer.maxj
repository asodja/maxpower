package maxpower.fft.buffer;

import java.util.ArrayList;
import java.util.List;

import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Params;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.KernelObject;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.KernelType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

public class FftBuffer {

	public static <T extends KernelObject<T>> List<T> buffer(List<T> input, DFEVar enable, int fftSize,
			int radix, int numPipes, int numOutputs) {
		KernelLib k = input[0].getKernel();
		if (fftSize % (numPipes * numOutputs) != 0) {
			throw new RuntimeException("fftSize must be divisible by both numPipes and numOutputs.");
		}
		int bufferDepth = fftSize / numPipes;

		List<DFEVar> packedInput = packInput(input);
		DFEVector<DFEVar> output;
		final int height = bufferDepth / numOutputs / radix;
		if (height > 0) {
			List<DFEVar> transposedInput = new ArrayList<DFEVar>(numPipes);
			ArrayList<DFEVar> slicedInput = new ArrayList<DFEVar>(numPipes);
			for (int j = 0; j < packedInput.size(); j++) {
				slicedInput.add(packedInput[j]);
			}
			transposedInput.addAll(transpose(slicedInput, numPipes, enable));
			//TODO: add shuffle for multiple FFT case (eg. dual radix 2 buffer)
			DFEVector<DFEVar> packedData = DFEVectorType.newInstance(transposedInput);
			DFEVectorType<DFEVar> packedType = packedData.getType();

			Transposer transposeBuffer = new Transposer(k, packedData.pack(), radix, height,
					numOutputs, enable);
			output = packedType.unpack(transposeBuffer.getOutput());
		} else {
			DFEVector<DFEVar> packedData = DFEVectorType.newInstance(packedInput);
			DFEVectorType<DFEVar> packedType = packedData.getType();

			Transposer transposeBuffer = new Transposer(k, packedData.pack(), bufferDepth / numOutputs,
					numOutputs, enable);
			output = packedType.unpack(transposeBuffer.getOutput());
		}

		DFEVector<DFEVar> offsetOutput = k.stream.offset(output, fftSize / numPipes);

		List<DFEVar> transposedOutput = transpose(offsetOutput.getElementsAsList(), numOutputs,
				k.stream.offset(enable, fftSize / numPipes));

		return unpackOutput(transposedOutput, input[0].getType());
	}

	private static <T extends KernelObject<T>> List<T>transpose(List<T> input, int numOutputs, DFEVar enable) {
		KernelLib k = input[0].getKernel();

		List<DFEVar> packedInput = packInput(input);

		final List<DFEVector<DFEVar>> inputToMux = new ArrayList<DFEVector<DFEVar>>(numOutputs);

		for (int i = 0; i < input.size(); i++) {
			DFEVectorType<DFEVar> arrayType = new DFEVectorType<DFEVar>(packedInput[i].getType(), numOutputs);
			final DFEVector<DFEVar> array = arrayType.newInstance(k);
			for (int j = 0; j < numOutputs; j++) {
				array.connect(j, k.stream.offset(packedInput[i], j));
			}
			inputToMux.add(k.stream.offset(array, -i));
		}
		Params params = k.control.count.makeParams(MathUtils.bitsToAddress(input.size()))
				.withMax(input.size()).withEnable(enable);
		DFEVar  select = k.control.count.makeCounter(params).getCount();
		final DFEVector<DFEVar> packedOutput = k.control.mux(select, inputToMux);

		return unpackOutput(packedOutput, input[0].getType());
	}

	private static <T extends KernelObject<T>> List<DFEVar>packInput(List<T> input) {
		List<DFEVar> packedInput = new ArrayList<DFEVar>(input.size());
		for (int i = 0; i < input.size(); i++) {
			packedInput.add(input[i].pack());
		}
		return packedInput;
	}

	private static <T extends KernelObject<T>> List<T>unpackOutput(DFEVector<DFEVar> packedOutput,
			KernelType<T> type) {
		return unpackOutput(packedOutput.getElementsAsList(), type);
	}

	private static <T extends KernelObject<T>> List<T>unpackOutput(List<DFEVar> packedOutput,
			KernelType<T> type) {
		List<T> output = new ArrayList<T>(packedOutput.size());
		for (int i = 0; i < packedOutput.size(); i++) {
			output.add(type.unpack(packedOutput[i]));
		}
		return output;
	}
}
