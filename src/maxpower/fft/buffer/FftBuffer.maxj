package maxpower.fft.buffer;

import java.util.ArrayList;
import java.util.List;

import maxpower.fft.FftFactory4pipes;

import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Params;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.KernelObject;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.KernelType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

/**
 * Buffer to store data between two stages of the fft.
 */
public class FftBuffer {

	/**
	 * Creates a buffer to store data between two stages in the fft.
	 *
	 * @param input Data from the previous fft stage.
	 * @param fftSize Size of the fft and by this also size of the buffer.
	 * @param radix Radix of the fft stage feeding into the buffer.
	 * @param numOutputs Radix of the fft stage consuming data from the buffer.
	 * @return Data to be feed into the next fft stage.
	 */
	public static <T extends KernelObject<T>> List<T> buffer(List<T> input, int fftSize, int radix,
			int numOutputs) {
		int numPipes = FftFactory4pipes.NUM_FFT_PIPES;

		KernelLib kernel = input[0].getKernel();
		if (fftSize % (numPipes * numOutputs) != 0) {
			throw new RuntimeException("fftSize must be divisible by both numPipes and numOutputs.");
		}
		int bufferDepth = fftSize / numPipes;

		List<DFEVar> packedInput = packInput(input);
		DFEVector<DFEVar> output;
		final int height = bufferDepth / numOutputs / radix;
		if (height > 0) {
			List<DFEVar> transposedInput = new ArrayList<DFEVar>(numPipes);
			ArrayList<DFEVar> slicedInput = new ArrayList<DFEVar>(numPipes);
			for (int j = 0; j < packedInput.size(); j++) {
				slicedInput.add(packedInput[j]);
			}
			transposedInput.addAll(transpose(slicedInput, numPipes));
			//TODO: add shuffle for multiple FFT case (eg. dual radix 2 buffer)
			DFEVector<DFEVar> packedData = DFEVectorType.newInstance(transposedInput);
			DFEVectorType<DFEVar> packedType = packedData.getType();

			Transposer transposeBuffer = new Transposer(kernel, packedData.pack(), radix, height,
					numOutputs, kernel.constant.var(true));
			output = packedType.unpack(transposeBuffer.getOutput());
		} else {
			DFEVector<DFEVar> packedData = DFEVectorType.newInstance(packedInput);
			DFEVectorType<DFEVar> packedType = packedData.getType();

			Transposer transposeBuffer = new Transposer(kernel, packedData.pack(), bufferDepth / numOutputs,
					numOutputs, kernel.constant.var(true));
			output = packedType.unpack(transposeBuffer.getOutput());
		}

		DFEVector<DFEVar> offsetOutput = kernel.stream.offset(output, fftSize / numPipes);

		List<DFEVar> transposedOutput = transpose(offsetOutput.getElementsAsList(), numOutputs);

		return unpackOutput(transposedOutput, input[0].getType());
	}

	private static <T extends KernelObject<T>> List<T>transpose(List<T> input, int numOutputs) {
		KernelLib kernel = input[0].getKernel();

		List<DFEVar> packedInput = packInput(input);

		final List<DFEVector<DFEVar>> inputToMux = new ArrayList<DFEVector<DFEVar>>(numOutputs);

		for (int i = 0; i < input.size(); i++) {
			DFEVectorType<DFEVar> arrayType = new DFEVectorType<DFEVar>(packedInput[i].getType(), numOutputs);
			final DFEVector<DFEVar> array = arrayType.newInstance(kernel);
			for (int j = 0; j < numOutputs; j++) {
				array.connect(j, kernel.stream.offset(packedInput[i], j));
			}
			inputToMux.add(kernel.stream.offset(array, -i));
		}
		Params params = kernel.control.count.makeParams(MathUtils.bitsToAddress(input.size()))
				.withMax(input.size());
		DFEVar  select = kernel.control.count.makeCounter(params).getCount();
		final DFEVector<DFEVar> packedOutput = kernel.control.mux(select, inputToMux);

		return unpackOutput(packedOutput, input[0].getType());
	}

	private static <T extends KernelObject<T>> List<DFEVar>packInput(List<T> input) {
		List<DFEVar> packedInput = new ArrayList<DFEVar>(input.size());
		for (int i = 0; i < input.size(); i++) {
			packedInput.add(input[i].pack());
		}
		return packedInput;
	}

	private static <T extends KernelObject<T>> List<T>unpackOutput(DFEVector<DFEVar> packedOutput,
			KernelType<T> type) {
		return unpackOutput(packedOutput.getElementsAsList(), type);
	}

	private static <T extends KernelObject<T>> List<T>unpackOutput(List<DFEVar> packedOutput,
			KernelType<T> type) {
		List<T> output = new ArrayList<T>(packedOutput.size());
		for (int i = 0; i < packedOutput.size(); i++) {
			output.add(type.unpack(packedOutput[i]));
		}
		return output;
	}
}
