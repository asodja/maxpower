package maxpower.fft.buffer;

import java.util.ArrayList;
import java.util.List;

import maxpower.fft.RadixType;
import maxpower.fft.buffer.CyclicAddressFactory.CyclicAddress;

import com.maxeler.maxcompiler.v0.utils.MathUtils;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler._KernelConfiguration;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.KernelMath;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.Reductions;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Counter;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.photon.configuration.PhotonPlatform;

/**
 * {@link CyclicAddress Cyclic address} implementation for initial input.
 *
 * @author simon
 */
public class InputAddress extends KernelLib implements CyclicAddress {
	/** Radix of FFT. */
	private final int m_radix;
	/** Binary shift to convert exponent of radix to binary. */
	private final int m_radixShift;
	/** Exponent of FFT radix (i.e. N = radix ^ exponent). */
	private final int m_exponent;
	/** Number of buffers. */
	private final int m_noBuffers;
	/** Number of bits to represent FFT values (i.e. N = 1 << N_BITS). */
	private final int m_noBits;
	/** Number of bits to represent data sets. */
	private final int m_noDataSetBits;
	/** Number of data sets. */
	private final int m_noDataSets;
	/** Number of values per buffer. */
	private final int m_valuesPerBuffer;
	/** Number of cycles (same as exponent). */
	private final int m_noCycles;
	/** Enable processing. */
	private final DFEVar m_enable;
	/** {@link DFEType HW type} for addresses. */
	private final DFEType m_addressType;

	/** List containing address pattern. */
	private final List<DFEVar> m_address;
	/** Boolean indication of buffer inversion. */
	private final DFEVar m_invertBuffer;
	/** Boolean indication of when output is available. */
	private final DFEVar m_outputAvailable;
	/** Which buffer we are using for writing. */
	private final DFEVar m_writeBuffer;
	/** Size of each buffer. */
	private final int m_bufferSize;
	/** Set to true if you want all addresses to start from cycle 0. */
	private final boolean m_offsetAddresses;

	public InputAddress(final RadixType radixType,
			final int exponent, final int noBuffers, final DFEVar startAddressing) {
		this(radixType, exponent, noBuffers, startAddressing, true);
	}
	/**
	 * Constructor to create {@link InputAddress input address}.
	 *
	 * @param kernel {@link KernelLib Kernel} object.
	 * @param radixType {@link RadixType Radix} of FFT.
	 * @param exponent Exponent of radix.
	 * @param noBuffers Number of RAM buffers to use (max 2 values per buffer
	 * 		with dual port RAM).
	 * @param startAddressing Indication of whether to start addressing.
	 */
	public InputAddress(final RadixType radixType,
			final int exponent, final int noBuffers,
			final DFEVar startAddressing,
			final boolean offsetAddresses) {
		super(startAddressing.getKernel());
		m_radix = radixType.getRadix();
		m_radixShift = radixType.getBinaryShift();
		m_exponent = exponent;
		m_noBuffers = noBuffers;
		m_enable = Reductions.streamHold(constant.var(true), startAddressing);
		m_offsetAddresses = offsetAddresses;

		m_noBits = m_exponent * m_radixShift;
		m_noDataSetBits = m_noBits - m_radixShift;
		m_noDataSets = 1 << m_noDataSetBits;
		m_valuesPerBuffer = m_radix / m_noBuffers;
		m_noCycles = m_exponent;
		m_bufferSize = m_valuesPerBuffer << m_noDataSetBits;
		m_addressType = dfeUInt(MathUtils.bitsToAddress(m_bufferSize));

		final CounterChain chain = control.count.makeCounterChainMoreBits(m_enable);
		final DFEVar cycleCount = chain.addCounter(m_noCycles, 1);
		final DFEVar dataCount = chain.addCounter(m_noDataSets, 1);

		if (_KernelConfiguration.getPhotonKernelConfig(getManager().getCurrentKernelConfig()).getPlatform()
				== PhotonPlatform.AlteraDefault) {
			final Counter bufferCounter = control.count.makeCounter(
					control.count.makeParams(1)
							.withEnable(chain.getCurrentCounterWrap()));
			m_writeBuffer = bufferCounter.getCount() === 0;
		} else {
			m_writeBuffer = null;
		}

		m_address = calculateAddressPattern(dataCount, cycleCount);
		m_invertBuffer = calculateInvertPattern(dataCount);
		m_outputAvailable = calculateOuputAvailable(cycleCount);
	}

	@Override
	public List<DFEVar> getAddress() {
		return m_address;
	}

	@Override
	public DFEVar isBufferInverted() {
		return m_invertBuffer;
	}

	@Override
	public DFEVar isOutputAvailable() {
		return m_outputAvailable;
	}

	@Override
	public int getBufferSize() {
		return m_bufferSize;
	}

	@Override
	public DFEVar getWriteBuffer() {
		return m_writeBuffer;
	}

	@Override
	public boolean getOffsetAddresses() {
		return m_offsetAddresses;
	}

	/**
	 * Calculate the address pattern for the streams.
	 *
	 * @param dataCount Current data set count.
	 * @param cycleCount Current buffer cycle count.
	 * @return {@link List} of buffer addresses.
	 */
	private List<DFEVar> calculateAddressPattern(
			final DFEVar dataCount, final DFEVar cycleCount) {
		final List<DFEVar> addresses = new ArrayList<DFEVar>(m_radix);
		final DFEType valueType = dfeUInt(m_noBits);
		for (int i = 0; i < m_radix; i++) {
			// First calculate position in stream.
			DFEVar value = (dataCount.cast(valueType) << m_radixShift) + i;
			// Next cycle the buffer location.
			for (int cycle = 1; cycle < m_noCycles; cycle++) {
				final DFEVar newValue =
						(KernelMath.modulo(value, m_radix).cast(valueType)
								<< m_noDataSetBits)
						+ (value >> m_radixShift);
				value = cycle <= cycleCount ? newValue : value;
			}
			DFEVar address = value;
			if (m_noBuffers > 1) {
				// Multiple buffers - work out where in the buffer it is.
				address = (value >> m_radixShift) * m_valuesPerBuffer
						+ KernelMath.modulo(value, m_valuesPerBuffer)
								.cast(valueType);
			}
			addresses.add(address.cast(m_addressType));
		}
		return addresses;
	}

	/**
	 *  Calculate buffer inversion pattern.
	 *
	 * @param dataCount Current data set count.
	 * @return Indication of whether buffers should be inverted.
	 */
	private DFEVar calculateInvertPattern(final DFEVar dataCount) {
		DFEVar invert = constant.var(false);
		// Check we have enough buffers to need an inversion.
		if (m_noBuffers > 1) {
			for (int i = 0; i < (m_exponent - 1); i++) {
				final int expShift = i * m_radixShift;
				final DFEVar sector =
						KernelMath.modulo(dataCount >> expShift, m_radix);
				invert = sector < (m_radix >> 1) ? invert : ~invert;
			}
		}
		return invert;
	}

	/**
	 * Calculate whether output data is available. Output should be valid
	 * after one full buffer cycle.
	 *
	 * @param cycleCount Current buffer cycle count.
	 * @return Indication of whether output is valid.
	 */
	private DFEVar calculateOuputAvailable(final DFEVar cycleCount) {
		return Reductions.streamHold(constant.var(true), cycleCount.gt(0));
	}
}
