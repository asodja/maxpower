package maxpower.fft.buffer;

import java.util.ArrayList;
import java.util.List;

import maxpower.fft.RadixType;

import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.CountMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Counter;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.WrapMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEComplex;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEComplexType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

/**
 * Cyclic buffer implementation for radix-5 FFT input stage.
 *
 * Data comes in sequentially at 4 values per cycle. For N=2048, inputs would
 * be in order [0/1/2/3, 4/5/6/7] and outputs [0/512/1024/1536,
 * 1/513/1025/1537] etc. The fifth value is a constant 0 added later.
 *
 * @author simon
 */
public class R5InputBuffer extends KernelLib {
	private static final boolean m_debug_watches = false;

	private static final int m_radix = RadixType.RADIX_4.getRadix();
	private static final int m_radixShift = RadixType.RADIX_4.getBinaryShift();
	private static final int m_valuesPerBuffer = 2;
	private static final int m_numBuffers = m_radix / m_valuesPerBuffer;

	private final DFEVar	m_enable;
	private final DFEVar	m_writeBuffer;
	private final int		m_numCycles;
	private final int		m_numDataSets;
	private final int		m_numDataPoints;
	private final int		m_exponent;
	private final int		m_bufferSize;
	private final DFEType 	m_addressType;

	/** List containing address pattern. */
	private final List<DFEVar> m_address;
	/** Boolean indication of buffer inversion. */
	private final DFEVar m_invertBuffer;

	/**
	 *
	 * Constructor to create {@link R5InputBuffer transpose input buffer}.
	 *
	 * @param owner {@link KernelLib Kernel} object.
	 * @param enable Indication of whether to start addressing.
	 */
	public R5InputBuffer(final KernelLib owner, int numPoints, int padding) {
		super(owner);
		m_enable = control.count.simpleCounter(MathUtils.bitsToAddress(5), 5) < 4;
		m_exponent = MathUtils.bitsToAddress(numPoints);
		m_bufferSize = (int)Math.pow(2, m_exponent) / m_numBuffers;
		m_addressType = dfeUInt(MathUtils.bitsToAddress(m_bufferSize));
		m_numCycles = m_exponent;
		m_numDataSets = m_bufferSize / m_valuesPerBuffer;

		m_numDataPoints = numPoints + padding;

		if (m_numDataPoints % 5 != 0) {
			throw new RuntimeException("Can only perform a radix 5 FFT on a number of points that is a multiple of 5.\n" +
										"This number is the total number of points you want to transform + any zero padding on the end.");
		}
		if (padding < m_numDataPoints / 5) {
			throw new RuntimeException("The current radix 5 implementation only supports inputs where the final fifth of the data is zero." +
										"This is simply an optimization for the most common use-case and the generic version has not been implemented yet.");
		}

		final Counter dataCounter = control.count.makeCounter(
				control.count.makeParams(MathUtils.bitsToAddress(m_numDataSets))
						.withEnable(m_enable)
						.withCountMode(CountMode.NUMERIC_INCREMENTING)
						.withInitValue(0)
						.withInc(1)
						.withMax(m_numDataSets)
						.withWrapMode(WrapMode.COUNT_LT_MAX_THEN_WRAP)
						.withWrapValue(0));
		final Counter cycleCounter = control.count.makeCounter(
				control.count.makeParams(MathUtils.bitsToAddress(m_numCycles))
						.withEnable(dataCounter.getWrap())
						.withCountMode(CountMode.NUMERIC_INCREMENTING)
						.withInitValue(0)
						.withInc(2)
						.withMax(m_numCycles)
						.withWrapMode(WrapMode.MODULO_MAX_OF_COUNT));
		final DFEVar dataCount = dataCounter.getCount();
		final DFEVar cycleCount = cycleCounter.getCount();

		if (PlatformUtils.isDoubleBufferingRequired(this)) {
			final Counter bufferCounter = control.count.makeCounter(
					control.count.makeParams(1)
							.withEnable(dataCounter.getWrap()));

			m_writeBuffer = bufferCounter.getCount() === 0;
		} else {
			m_writeBuffer = null;
		}
		m_address = calculateAddressPattern(dataCount, cycleCount);
		m_invertBuffer = calculateInvertPattern(dataCount);
	}

	public DFEVar acceptingInput() {
		return m_enable;
	}

	/**
	 * Transpose the inputs according the addressing pattern.
	 *
	 * @param input List of inputs to transpose.
	 * @return List of transposed outputs.
	 */
	public List<DFEVector<DFEComplex>> transpose(final List<DFEVector<DFEComplex>> input) {
		final List<DFEVector<DFEComplex>> ramOut = new ArrayList<DFEVector<DFEComplex>>(m_radix);
		final BufferRamFactory<DFEVector<DFEComplex>, DFEVector<DFEComplex>> buffer =
			new BufferRamFactory<DFEVector<DFEComplex>, DFEVector<DFEComplex>>(m_bufferSize, m_enable, m_writeBuffer);

		for (int i = 0; i < m_numBuffers; i++) {
			final int index = i;
			final int invertIndex = m_numBuffers - i - 1;

			final List<DFEVar> addr;
			final List<DFEVector<DFEComplex>> ramIn;

			if (m_numBuffers > 1) {
				addr	= new ArrayList<DFEVar>(2);
				ramIn 	= new ArrayList<DFEVector<DFEComplex>>(2);
				addr.add(m_invertBuffer ?
							m_address.get(invertIndex) : m_address.get(index));
				addr.add(m_invertBuffer ?
							m_address.get(m_radix - invertIndex - 1) :
							m_address.get(m_radix - index - 1));
				ramIn.add(m_invertBuffer ?
							input.get(invertIndex) : input.get(index));
				ramIn.add(m_invertBuffer ?
							input.get(m_radix - invertIndex - 1) :
							input.get(m_radix - index - 1));
			} else { // Single buffer - no need for inversion.
				addr	= m_address;
				ramIn	= input;
			}

			ramOut.addAll(buffer.dualRam(addr, ramIn));
		}

		final List<DFEVector<DFEComplex>> shuffledRamOut = new ArrayList<DFEVector<DFEComplex>>(m_radix);
		if (m_numBuffers > 1) { // Multiple buffers.
			// Shuffle output order according to inversion pattern.
			for (int i = 0; i < m_numBuffers; i++) {
				final int index = (i * m_valuesPerBuffer) + i;
				final int invertIndex = (index + m_valuesPerBuffer) % m_radix;
				shuffledRamOut.add(m_invertBuffer ?
						ramOut.get(invertIndex) : ramOut.get(index));
				shuffledRamOut.add(m_invertBuffer ?
						ramOut.get((invertIndex + m_valuesPerBuffer) % m_radix) :
						ramOut.get((index + m_valuesPerBuffer) % m_radix));
			}
		} else { // Single buffer - just add list directly.
			shuffledRamOut.addAll(ramOut);
		}

		final List<DFEVector<DFEComplex>> output = new ArrayList<DFEVector<DFEComplex>>(5);
		int offset = m_numDataPoints / 4;
		for (int i = 0; i < 4; i++) {
			output.add(stream.offset(shuffledRamOut[i], offset));
		}
		DFEVectorType<DFEComplex> mpType = output[0].getType();
		DFEComplexType complexType = (DFEComplexType) mpType.getContainedType();
		output.add(mpType.newInstance(this, constant.cplx(complexType, 0.0, 0.0)));
		return output;
	}

	/**
	 * Calculate the address pattern for the streams.
	 *
	 * @param dataCount Current data set count.
	 * @param cycleCount Current buffer cycle count.
	 * @return {@link List} of buffer addresses.
	 */
	private List<DFEVar> calculateAddressPattern(
			final DFEVar dataCount, final DFEVar cycleCount) {
		final List<DFEVar> addresses = new ArrayList<DFEVar>(m_radix);
		final DFEType valueType = dfeUInt(m_exponent);
		for (int i = 0; i < m_radix; i++) {
			// First calculate position in stream.
			final DFEVar value = (dataCount.cast(valueType) << m_radixShift) + i;
			final DFEVar position = (value >> cycleCount)
					| (value << (m_exponent - cycleCount))
					.cast(valueType);
			final DFEVar address;;
			if (m_numBuffers > 1) {
				// Multiple buffers - work out where in the buffer it is.
				address = (position >> m_radixShift) * m_valuesPerBuffer
						+ position.slice(m_radixShift - 1).cast(dfeUInt(1)).cast(position.getType());
			} else {
				address = position;
			}
			if (m_debug_watches) {
				value.simWatch("tin_value" + i);
				position.simWatch("tin_position" + i);
				address.simWatch("tin_address" + i);
			}
			addresses.add(address.cast(m_addressType));
		}
		return addresses;
	}

	/**
	 *	Calculate buffer inversion pattern.
	 *
	 * @param dataCount Current data set count.
	 * @return Indication of whether buffers should be inverted.
	 */
	private DFEVar calculateInvertPattern(final DFEVar dataCount) {
		DFEVar invert = constant.var(false);
		// Check we have enough buffers to need an inversion.
		if (m_numBuffers > 1) {
			for (int i = 0; i < (m_exponent - 1); i++) {
				final DFEVar sector = (dataCount >> i).slice(0);
				invert = sector ? ~invert : invert;
			}
		}
		return invert;
	}

}
