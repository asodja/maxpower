package maxpower.fft.buffer;

import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.KernelMath;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Mem.DualPortMemOutputs;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Mem.RamPortMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Mem.RamPortParams;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Mem.RamWriteMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Stream.OffsetExpr;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

/**
 * Use single buffer to transpose matrices.
 */
public class Transposer {

	private static int offset_counter = 0;

	/**
	 * For minimal resource usage, choose width and height such that
	 * (width*height-1) is an exact power of two.
	 *
	 * Note that you must have width*height>=17
	 *
	 * Example:
	 * Assume width of 4 and height of 3, with values
	 *
	 *	0	|	1	|	2	|	3
	 *	4	|	5	|	6	|	7
	 *	8	|	9	|	10	|	11
	 *
	 *	Then the output will return (after 12 cycles since the output does not hide the latency)
	 *		0, 4, 8, 1, 5, 9, 2, 6, 10, 3, 7, 11
	 *
	 * width     fast dimension
	 * height    slow dimension
	 **/
	public static DFEVar transpose(KernelLib owner, DFEVar in, int width, int height, DFEVar enable) {
		return transpose(owner, in, width, 1, height, enable);
	}

	/**
	 * This one differs from constructor Transposer(KernelLib owner, HWVar in, int width, int height, HWVar enable) in that
	 * movement in the horizontal directions, when transposing, are not by one column but by a user defined amount.
	 *
	 * Example:
	 * Assume width (fast) of 5 and height (medium) of 3 and depth (slow) of 2, with values
	 *
	 *	0	|	1	|	2	|	3	|	4
	 *	10	|	11	|	12	|	13	|	14
	 *	20	|	21	|	22	|	23	|	24
	 *
	 *	5	|	6	|	7	|	8	|	9
	 *	15	|	16	|	17	|	18	|	19
	 *	25	|	26	|	27	|	28	|	29
	 *
	 *	Then the output will return
	 *		0, 5, 10, 15, 20, 25, 1, 6, 11, 16, ...
	 *
	 * width     fast dimension
	 * height    medium dimension
	 * depth     slow dimension
	 **/
	public static DFEVar transpose(KernelLib owner, DFEVar in, int width, int height, int depth, DFEVar enable) {
		final int N = width * height * depth;;
		final boolean isDoubleBuffered;

		DFEVar writeAddress;
		DFEVar readAddress;

		if (height == 1) {
			isDoubleBuffered = false;

			final int Nm = N - 1;
			final int nBits = MathUtils.bitsToAddress(N);

			DFEVar isFirst = owner.control.count.pulse(1);

			DFEVar i = owner.control.count.makeCounter(owner.control.count.makeParams(nBits).withEnable(enable).withMax(N)).getCount();
			DFEVar mul = KernelLib.dfeUInt(nBits).newInstance(owner);
			owner.optimization.pushEnableBitGrowth(true);
			DFEVar address = i === Nm ? Nm : KernelMath.modulo(i * mul, Nm).cast(KernelLib.dfeUInt(nBits));
			DFEVar nextMul = mul * KernelLib.dfeUInt(MathUtils.bitsToRepresent(width)).newInstance(owner, width);
			owner.optimization.popEnableBitGrowth();
			nextMul = KernelMath.modulo(nextMul, Nm).cast(KernelLib.dfeUInt(nBits));
			OffsetExpr offset = owner.stream.makeOffsetAutoLoop("transposerOffset" + offset_counter++, 0, N);
			mul <== owner.control.mux(isFirst#(i===0), owner.stream.offset(mul, -1),
					owner.stream.offset(nextMul, -offset), owner.constant.var(1), owner.constant.var(1));

			writeAddress = address;
			readAddress = address;

			owner.getManager().logInfo("Depth of RAM in Transposer = " + N);
		} else if (width == depth) {
			isDoubleBuffered = false;

			DFEType addressType = KernelLib.dfeUInt(MathUtils.bitsToAddress(N));

			CounterChain readCounter = owner.control.count.makeCounterChain(enable);

			DFEVar changePattern = readCounter.addCounter(2,      1);
			DFEVar slow          = readCounter.addCounter(width,  1).cast(addressType);
			DFEVar medium        = readCounter.addCounter(height, 1).cast(addressType);
			DFEVar fast          = readCounter.addCounter(depth,  1).cast(addressType);

			DFEVar cycleCounter = owner.control.count.simpleCounter(MathUtils.bitsToAddress(N), N);

			DFEVar address = changePattern === 0 ? cycleCounter :
					fast * width * height + medium * width + slow;

			writeAddress = address;
			readAddress = address;
		} else {
			// double buffered implementation
			isDoubleBuffered = true;

			DFEType addressType = KernelLib.dfeUInt(MathUtils.bitsToAddress(2 * N));
			CounterChain readCounter = owner.control.count.makeCounterChain(enable);
			CounterChain writeCounter = owner.control.count.makeCounterChain(enable);

			DFEVar rdBuff = readCounter.addCounter(2,      1);
			DFEVar slow   = readCounter.addCounter(width,  1).cast(addressType);
			DFEVar medium = readCounter.addCounter(height, 1).cast(addressType);
			DFEVar fast   = readCounter.addCounter(depth,  1).cast(addressType);

			readAddress  = fast * width * height + medium * width + slow;
			writeAddress = writeCounter.addCounter(N, 1).cast(addressType);

			writeAddress = rdBuff ? writeAddress    : writeAddress + N;
			readAddress  = rdBuff ? readAddress + N : readAddress;
		}

		final int ramSize = isDoubleBuffered ? 2 * N : N;

		RamPortParams<DFEVar> writePort   = owner.mem.makeRamPortParams(RamPortMode.WRITE_ONLY, writeAddress, in).withWriteEnable(enable);
		RamPortParams<DFEVar> readPort    = owner.mem.makeRamPortParams(RamPortMode.READ_ONLY,  readAddress,  in.getType());
		DualPortMemOutputs<DFEVar> buffer = owner.mem.ramDualPort(ramSize, RamWriteMode.READ_FIRST, writePort, readPort);

		return buffer.getOutputB();
	}
}
