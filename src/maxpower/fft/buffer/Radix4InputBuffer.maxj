package maxpower.fft.buffer;

import java.util.ArrayList;
import java.util.List;

import maxpower.fft.Radix;

import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Counter;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.WrapMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEComplex;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

/**
 * Cyclic buffer implementation for radix-4 FFT input stage.
 *
 * Data comes in sequentially at 4 values per cycle. For N=2048, inputs would
 * be in order [0/1/2/3, 4/5/6/7] and outputs [0/512/1024/1536,
 * 1/513/1025/1537] etc.
 *
 * @author Simon Tilbury
 */
public class Radix4InputBuffer extends KernelLib {
	private static final boolean m_debug_watches = false;

	/** Radix of FFT. */
	private static final int m_radix = Radix.RADIX_4.getRadix();
	/** Binary shift to convert exponent of radix to binary. */
	private static final int m_radixShift = Radix.RADIX_4.getBinaryShift();
	private static final int m_valuesPerBuffer = 2;
	/** Number of buffers. */
	private static final int m_numBuffers = m_radix / m_valuesPerBuffer;

	/** Exponent of 2 (i.e. N = 2 ^ exponent). */
	private final int m_exponent;

	/** Number of data sets. */
	private final int     m_numDataSets;
	private final int     m_numCycles;
	private final int     m_numDataPoints;

	private final DFEVar  m_writeBuffer;
	/** {@link DFEType HW type} for addresses. */
	private final DFEType m_addressType;

	/** List containing address pattern. */
	private final List<DFEVar> m_address;
	/** Boolean indication of buffer inversion. */
	private final DFEVar m_doInvertBuffer;
	/** Size of each buffer. */
	private final int m_bufferSize;

	/**
	 * Constructor to create {@link Radix4InputBuffer transpose input buffer}.
	 *
	 * @param owner {@link KernelLib Kernel} object.
	 * @param numPoints number of points to work on
	 */
	public Radix4InputBuffer(final KernelLib owner, int numPoints) {
		super(owner);
		m_numDataPoints = numPoints;

		m_exponent = MathUtils.bitsToAddress(m_numDataPoints);
		m_bufferSize = (int)Math.pow(2, m_exponent) / m_numBuffers;
		m_addressType = dfeUInt(MathUtils.bitsToAddress(m_bufferSize));
		m_numCycles = m_exponent;
		m_numDataSets = m_bufferSize / m_valuesPerBuffer;


		if (m_numDataPoints % 4 != 0) {
			throw new RuntimeException("Can only perform a radix 4 FFT on a number of points that is a multiple of 4.");
		}

		final Counter dataCounter = control.count.makeCounter(
				control.count.makeParams(MathUtils.bitsToAddress(m_numDataSets))
						.withMax(m_numDataSets)
						.withWrapValue(0));
		final Counter cycleCounter = control.count.makeCounter(
				control.count.makeParams(MathUtils.bitsToAddress(m_numCycles))
						.withEnable(dataCounter.getWrap())
						.withInc(2)
						.withMax(m_numCycles)
						.withWrapMode(WrapMode.MODULO_MAX_OF_COUNT));
		final DFEVar dataCount = dataCounter.getCount();
		final DFEVar cycleCount = cycleCounter.getCount();

		final Counter bufferCounter = control.count.makeCounter(
				control.count.makeParams(1)
						.withEnable(dataCounter.getWrap()));

		m_writeBuffer = bufferCounter.getCount() === 0;

		m_address = calculateAddressPattern(dataCount, cycleCount);
		if (m_numBuffers > 1) {
			m_doInvertBuffer = calculateIfBufferShouldBeInverted(dataCount);
		} else {
			m_doInvertBuffer = null;
		}
	}

	/**
	 * Transpose the inputs according the addressing pattern.
	 *
	 * @param input List of inputs to transpose.
	 * @return List of transposed outputs.
	 */
	public List<DFEVector<DFEComplex>> transpose(final List<DFEVector<DFEComplex>> input) {
		final List<DFEVector<DFEComplex>> ramOut = new ArrayList<DFEVector<DFEComplex>>(m_radix);

		for (int index = 0; index < m_numBuffers; index++) {
			final int invertIndex = m_numBuffers - index - 1;

			final List<DFEVar> addr;
			final List<DFEVector<DFEComplex>> ramIn;

			if (m_numBuffers > 1) {
				addr  = new ArrayList<DFEVar>(2);
				ramIn = new ArrayList<DFEVector<DFEComplex>>(2);
				addr.add(m_doInvertBuffer ?
						m_address.get(invertIndex) : m_address.get(index));
				addr.add(m_doInvertBuffer ?
						m_address.get(m_radix - invertIndex - 1) :
						m_address.get(m_radix - index - 1));
				ramIn.add(m_doInvertBuffer ?
						input.get(invertIndex) : input.get(index));
				ramIn.add(m_doInvertBuffer ?
						input.get(m_radix - invertIndex - 1) :
						input.get(m_radix - index - 1));
			} else { // Single buffer - no need for inversion.
				addr  = m_address;
				ramIn = input;
			}

			ramOut.addAll(BufferRam.dualRam(m_bufferSize, constant.var(true), m_writeBuffer, addr,
					ramIn));
		}

		final List<DFEVector<DFEComplex>> shuffledRamOut = new ArrayList<DFEVector<DFEComplex>>(m_radix);
		if (m_numBuffers > 1) { // Multiple buffers.
			// Shuffle output order according to inversion pattern.
			for (int i = 0; i < m_numBuffers; i++) {
				final int index = (i * m_valuesPerBuffer) + i;
				final int invertIndex = (index + m_valuesPerBuffer) % m_radix;
				shuffledRamOut.add(m_doInvertBuffer ?
						ramOut.get(invertIndex) : ramOut.get(index));
				shuffledRamOut.add(m_doInvertBuffer ?
						ramOut.get((invertIndex + m_valuesPerBuffer) % m_radix) :
						ramOut.get((index + m_valuesPerBuffer) % m_radix));
			}
		} else { // Single buffer - just add list directly.
			shuffledRamOut.addAll(ramOut);
		}

		final List<DFEVector<DFEComplex>> output = new ArrayList<DFEVector<DFEComplex>>(4);
		int offset = m_numDataPoints / 4;
		for (int i = 0; i < 4; i++) {
			output.add(stream.offset(shuffledRamOut[i], offset));
		}
		return output;
	}

	/**
	 * Calculate the address pattern for the streams.
	 *
	 * @param dataCount Current data set count.
	 * @param cycleCount Current buffer cycle count.
	 * @return {@link List} of buffer addresses.
	 */
	private List<DFEVar> calculateAddressPattern(
			final DFEVar dataCount, final DFEVar cycleCount) {
		final List<DFEVar> addresses = new ArrayList<DFEVar>(m_radix);
		final DFEType valueType = dfeUInt(m_exponent);
		for (int i = 0; i < m_radix; i++) {
			// First calculate position in stream.
			final DFEVar value = (dataCount.cast(valueType) << m_radixShift) + i;
			final DFEVar position = (value >> cycleCount)
					| (value << (m_exponent - cycleCount))
					.cast(valueType);
			final DFEVar address;;
			if (m_numBuffers > 1) {
				// Multiple buffers - work out where in the buffer it is.
				address = (position >> m_radixShift) * m_valuesPerBuffer
						+ position.slice(m_radixShift - 1).cast(dfeUInt(1)).cast(position.getType());
			} else {
				address = position;
			}
			if (m_debug_watches) {
				value.simWatch("tin_value" + i);
				position.simWatch("tin_position" + i);
				address.simWatch("tin_address" + i);
			}
			addresses.add(address.cast(m_addressType));
		}
		return addresses;
	}

	/**
	 *  Calculate buffer inversion pattern.
	 *
	 * @param dataCount Current data set count.
	 * @return Indication of whether buffers should be inverted.
	 */
	private DFEVar calculateIfBufferShouldBeInverted(final DFEVar dataCount) {
		DFEVar invert = constant.var(false);
		// Check we have enough buffers to need an inversion.
		if (m_numBuffers > 1) {
			for (int i = 0; i < (m_exponent - 1); i++) {
				final DFEVar sector = (dataCount >> i).slice(0);
				invert = sector ? ~invert : invert;
			}
		}
		return invert;
	}
}
