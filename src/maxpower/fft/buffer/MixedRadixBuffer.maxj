package maxpower.fft.buffer;

import java.util.ArrayList;
import java.util.List;

import maxpower.fft.RadixType;

import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.Reductions;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Counter;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEComplex;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

/**
 * Cyclic buffer implementation for mixed-radix FFT stage.
 *
 * Data comes in from two radix-2 FFTs to be fed into a single radix-4 FFT of
 * size N/2. For N=512, inputs would be in order [0/128/256/384, 1/129/257/385]
 * and outputs [0/64/128/192, 1/65/129/193] etc.
 *
 * @author simon
 */
public class MixedRadixBuffer extends KernelLib {
	private static final boolean m_debug_watches = false;

	/** Radix of FFT. */
	private static final int m_radix = RadixType.RADIX_4.getRadix();
	/** Binary shift to convert exponent of radix to binary. */
	private static final int m_radixShift = RadixType.RADIX_4.getBinaryShift();
	/** Number of buffers. */
	private static final int m_numBuffers = m_radix / 2;

	/** Exponent of 2 (i.e. N = 2 ^ exponent). */
	private final int m_exponent;

	/** Number of bits to represent FFT values (i.e. N = 1 << N_BITS). */
	private final int m_noBits;
	/** Number of bits to represent data sets. */
	private final int m_noDataSetBits;
	/** Number of data sets. */
	private final int m_noDataSets;
	/** Number of values per buffer. */
	private final int m_valuesPerBuffer;
	/** Number of cycles - always 3 for mixed radix. */
	private final static int NO_CYCLES = 3;
	/** Output offset. */
	private final int m_outputOffset;

	/** Enable processing. */
	private final DFEVar m_enable;
	private final DFEVar m_writeBuffer;
	/** {@link DFEType HW type} for addresses. */
	private final DFEType m_addressType;

	/** List containing address pattern. */
	private final List<DFEVar> m_address;
	/** Boolean indication of buffer inversion. */
	private final DFEVar m_invertBuffer;
	/** Size of each buffer. */
	private final int m_bufferSize;
	/** Current cycle count. */
	private final DFEVar m_cycleCount;
	/** Current data count. */
	private final DFEVar m_dataCount;

	/**
	 * Constructor to create {@link MixedRadixBuffer mixed radix buffer}.
	 *
	 * @param owner {@link KernelLib Kernel} object.
	 * @param exponent Exponent of radix.
	 * @param startAddressing Indication of whether to start addressing.
	 */
	public MixedRadixBuffer(final int exponent, final DFEVar startAddressing) {
		super(startAddressing.getKernel());
		m_exponent = exponent;
		m_enable = Reductions.streamHold(constant.var(true), startAddressing);

		m_noBits = m_exponent;
		m_noDataSetBits = m_noBits - m_radixShift;
		m_noDataSets = 1 << m_noDataSetBits;
		m_outputOffset = m_noDataSets;
		m_valuesPerBuffer = m_radix / m_numBuffers;
		m_bufferSize = m_valuesPerBuffer << m_noDataSetBits;
		m_addressType = dfeUInt(MathUtils.bitsToAddress(m_bufferSize));

		final CounterChain chain = control.count.makeCounterChainMoreBits(m_enable);
		m_cycleCount = chain.addCounter(NO_CYCLES, 1);
		m_dataCount = chain.addCounter(m_noDataSets, 1);

		if (PlatformUtils.isDoubleBufferingRequired(this)) {
			final Counter bufferCounter = control.count.makeCounter(
					control.count.makeParams(1)
							.withEnable(chain.getCurrentCounterWrap()));
			m_writeBuffer = bufferCounter.getCount() === 0;
		} else {
			m_writeBuffer = null;
		}

		m_address = calculateAddressPattern();
		m_invertBuffer = calculateInvertPattern();
	}

	/**
	 * Get the output offset. This is calculated based on the data size, and
	 * is to allow RAM buffers time to fill.
	 *
	 * @return Offset to apply to output.
	 */
	public int getOutputOffset() {
		return m_outputOffset;
	}

	public DFEVar getDataCount() {
		return m_dataCount;
	}

	/**
	 * Transpose the inputs according the addressing pattern.
	 *
	 * @param input List of inputs to transpose.
	 * @return List of transposed outputs.
	 */
	public List<DFEVector<DFEComplex>> transpose(final List<DFEVector<DFEComplex>> input) {
		final List<DFEVector<DFEComplex>> ramOut = new ArrayList<DFEVector<DFEComplex>>(m_radix);
		BufferRamFactory<DFEVector<DFEComplex>, DFEVector<DFEComplex>> buffer = new BufferRamFactory<DFEVector<DFEComplex>, DFEVector<DFEComplex>>(m_bufferSize, m_enable, m_writeBuffer);
		for (int i = 0; i < m_numBuffers; i++) {
			final int index = i;
			final int invertIndex = m_numBuffers - i - 1;

			final List<DFEVar> addr;
			final List<DFEVector<DFEComplex>> ramIn;

			if (m_numBuffers > 1) {
				addr = new ArrayList<DFEVar>(2);
				addr.add(m_invertBuffer ?
						m_address.get(invertIndex) : m_address.get(index));
				addr.add(m_invertBuffer ?
						m_address.get(m_radix - invertIndex - 1) :
						m_address.get(m_radix - index - 1));

				ramIn = new ArrayList<DFEVector<DFEComplex>>(2);
				ramIn.add(m_invertBuffer ?
						input.get(invertIndex) : input.get(index));
				ramIn.add(m_invertBuffer ?
						input.get(m_radix - invertIndex - 1) :
						input.get(m_radix - index - 1));
			} else { // Single buffer - no need for inversion.
				addr = m_address;
				ramIn = input;
			}

			final List<DFEVector<DFEComplex>> bufferOutput = buffer.dualRam(addr, ramIn);
			for (int j = 0; j < bufferOutput.size(); j++) {
				ramOut.add(stream.offset(bufferOutput[j], getOutputOffset()));
			}
		}

		if (m_numBuffers > 1) { // Multiple buffers.
			// Shuffle output order according to inversion pattern.
			final List<DFEVector<DFEComplex>> output = new ArrayList<DFEVector<DFEComplex>>(m_radix);
			for (int i = 0; i < m_numBuffers; i++) {
				final int index = (i * m_valuesPerBuffer) + i;
				final int invertIndex = (index + m_valuesPerBuffer) % m_radix;
				output.add(m_invertBuffer ?
						ramOut.get(invertIndex) : ramOut.get(index));
				output.add(m_invertBuffer ?
						ramOut.get((invertIndex + m_valuesPerBuffer) % m_radix) :
						ramOut.get((index + m_valuesPerBuffer) % m_radix));
			}
			return output;
		}
		return ramOut;
	}

	/**
	 * Calculate the address pattern for the streams.
	 *
	 * @return {@link List} of buffer addresses.
	 */
	private List<DFEVar> calculateAddressPattern() {
		final List<DFEVar> addresses = new ArrayList<DFEVar>(m_radix);
		final DFEType valueType = dfeUInt(m_noBits);
		for (int i = 0; i < m_radix; i++) {
			// First calculate position in stream.
			final DFEVar position = m_dataCount.cast(valueType)
					+ (i << m_noDataSetBits);
			// Next cycle the buffer location if required.
			final DFEVar value = cyclePosition(position);
			final DFEVar address = value.slice(0, m_addressType.getTotalBits())
					.cast(m_addressType);
			addresses.add(address);
			if (m_debug_watches) {
				position.simWatch("mrb_position" + i);
				value.simWatch("mrb_value" + i);
				address.simWatch("mrb_address" + i);
			}
		}
		return addresses;
	}

	/**
	 *  Calculate buffer inversion pattern.
	 *
	 * @return Indication of whether buffers should be inverted.
	 */
	private DFEVar calculateInvertPattern() {
		final DFEVar invert;
		// Check we have enough buffers to need an inversion.
		if (m_numBuffers > 1) {
			invert = m_dataCount.slice(m_noDataSetBits - 1);
		} else {
			invert = constant.var(false);
		}
		return invert;
	}

	/**
	 * Cycle a position value by rotating the MS 3 bits.
	 *
	 * @param position Position in stream to cycle.
	 * @return Cycled position value.
	 */
	private DFEVar cyclePosition(final DFEVar position) {
		final DFEType positionType = position.getType();
		final int rotateBitStart = m_noBits - NO_CYCLES;

		final DFEVar rotateBits = position.slice(rotateBitStart, NO_CYCLES);
		final DFEVar rotate = (rotateBits >> m_cycleCount)
				| (rotateBits << (NO_CYCLES - m_cycleCount));
		final DFEVar newPosition = rotate.cat(position.slice(
				0, rotateBitStart)).cast(positionType);
		return newPosition;
	}
}
