package maxpower.fft;

import java.util.ArrayList;
import java.util.List;

import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEComplex;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.utils.MathUtils;


/**
 * Rearrange the data for the FFTFactory structure.
 * Not actually tested for nFFT > 1. beware!
 */
public class Encoder {

	public static List<DFEVector<DFEComplex>> encodeFftInput(DFEVector<DFEComplex> input,
			int nFFT, int nPipes) {
		List<DFEVector<DFEComplex>> list = new ArrayList<DFEVector<DFEComplex>>();
		DFEVectorType<DFEComplex> fftType = new DFEVectorType<DFEComplex>(input[0].getType(), nFFT);

		int bitsPerPipe = fftType.getTotalBits();
		for(int i = 0; i < nPipes; i++){
			list.add(fftType.unpack(input.pack().slice(i*bitsPerPipe, bitsPerPipe)));
		}
		return list;
	}

	public static DFEVector<DFEComplex> decodeFftOutput(List<DFEVector<DFEComplex>> input,
			int nFFT, int nPipes, int fftSize) {
		DFEVector<DFEComplex> result = new DFEVectorType<DFEComplex>(input.get(0).getType().getContainedType(),
				nPipes*nFFT).newInstance(input[0].getKernel());

		for (int i = 0; i < 4; i++) {
			for (int j = 0; j < nFFT; j++){
				result.connect(i*nFFT+j, input[i][j]);
			}
		}
		return bitReverseBuffer(result, fftSize);
	}

	/**
	 * Bit reverse the result of the FFT. ATTENTION: This will break for not equal to 4 pipes and non power of 2
	 * input sizes
	 * @param input fft results.
	 * @param fftSize Size of the fft.
	 * @return bit reversed result of the fft.
	 */
	protected static DFEVector<DFEComplex> bitReverseBuffer(DFEVector<DFEComplex> input, final int fftSize) {
		KernelLib owner = input.getKernel();
		final int ramSize = fftSize / FftFactory4pipes.NUM_FFT_PIPES;

		final int N = MathUtils.bitsToAddress(fftSize);

		CounterChain counterChain = owner.control.count.makeCounterChain();
		// if we write in linear order or in our crazy pattern
		DFEVar state       = counterChain.addCounter(2, 1);
		// We have for states that determine rotates, swaps and addresses
		DFEVar bufferState = counterChain.addCounter(4, 1);
		DFEVar position    = counterChain.addCounter(1 << (N - 4), 1);

		ArrayList<Memory<DFEComplex>> buffer = new ArrayList<Memory<DFEComplex>>();
		for (int i = 0; i < 4; i++) {
			buffer.add(owner.mem.alloc(input[0].getType(), ramSize));
		}

		// First we write to the buffer. We have to rotate buffer state times
		input = input.rotateElementsLeft(bufferState);

		// Now we have to calculate the addresses
		ArrayList<DFEVar> ramAddressUpperBitsMuxInput = getStartingPointsForAddressing(owner);
		DFEVar ramAddressUpperBits = owner.control.mux(bufferState, ramAddressUpperBitsMuxInput);

		DFEVar addresses[] = new DFEVar[4];
		for (int i = 0; i < 4; i++) {
			addresses[i] = ramAddressUpperBits + i # bitReverse(position);
			addresses[i] = addresses[i].cast(KernelLib.dfeUInt(2 + N - 4));
		}

		// Now we can finally access the RAM and do some reading and writing
		ArrayList<DFEComplex> lookupResults = new ArrayList<DFEComplex>();
		DFEVar dataCount = bufferState.cast(KernelLib.dfeUInt(2 + N - 4)) * (1 << (N - 4)) +
				position.cast(KernelLib.dfeUInt(2 + N - 4));
		for (int i = 0; i < 4; i++) {
			DFEVar finalAddress = state ? addresses[i] : dataCount;
			lookupResults.add(buffer[i].read(finalAddress));
			buffer[i].write(finalAddress, input[i], owner.constant.var(true));
		}

		// Now we still have to swap the output a bit
		ArrayList<ArrayList<DFEVar>> swapMuxSelectMuxInput = getMagicNumbersForSwapping(owner);

		DFEVector<DFEComplex> result = input.getType().newInstance(owner);
		for (int i = 0; i < 4; i++) {
			DFEVar swapMuxSelect = owner.control.mux(bufferState, swapMuxSelectMuxInput[i]);
			result[i] <== owner.control.mux(swapMuxSelect, lookupResults);
		}

		return owner.stream.offset(result, ramSize);
	}

	/**
	 * Function to reverse the bits of a given DFEVar.
	 * @param x DFEVar to revert the bits of.
	 * @return Bit reversed DFEVar
	 */
	private static DFEVar bitReverse(DFEVar x) {
		DFEVar result = x.slice(0);

		for (int i = 1; i < x.getType().getTotalBits(); i++) {
			result = result # x.slice(i);
		}

		return result.cast(x.getType());
	}

	private static ArrayList<DFEVar> getStartingPointsForAddressing(KernelLib owner) {
		ArrayList<DFEVar> ramAddressUpperBitsMuxInput = new ArrayList<DFEVar>();
		ramAddressUpperBitsMuxInput.add(owner.constant.var(KernelLib.dfeUInt(2), 0));
		ramAddressUpperBitsMuxInput.add(owner.constant.var(KernelLib.dfeUInt(2), 2));
		ramAddressUpperBitsMuxInput.add(owner.constant.var(KernelLib.dfeUInt(2), 3));
		ramAddressUpperBitsMuxInput.add(owner.constant.var(KernelLib.dfeUInt(2), 1));
		return ramAddressUpperBitsMuxInput;
	}

	private static ArrayList<ArrayList<DFEVar>> getMagicNumbersForSwapping(KernelLib owner) {
		ArrayList<ArrayList<DFEVar>> swapMuxSelectMuxInput = new ArrayList<ArrayList<DFEVar>>();
		for (int i = 0; i < 4; i++) {
			swapMuxSelectMuxInput.add(new ArrayList<DFEVar>());
		}
		swapMuxSelectMuxInput[0].add(owner.constant.var(KernelLib.dfeUInt(2), 0));
		swapMuxSelectMuxInput[0].add(owner.constant.var(KernelLib.dfeUInt(2), 2));
		swapMuxSelectMuxInput[0].add(owner.constant.var(KernelLib.dfeUInt(2), 1));
		swapMuxSelectMuxInput[0].add(owner.constant.var(KernelLib.dfeUInt(2), 3));
		swapMuxSelectMuxInput[1].add(owner.constant.var(KernelLib.dfeUInt(2), 2));
		swapMuxSelectMuxInput[1].add(owner.constant.var(KernelLib.dfeUInt(2), 0));
		swapMuxSelectMuxInput[1].add(owner.constant.var(KernelLib.dfeUInt(2), 3));
		swapMuxSelectMuxInput[1].add(owner.constant.var(KernelLib.dfeUInt(2), 1));
		swapMuxSelectMuxInput[2].add(owner.constant.var(KernelLib.dfeUInt(2), 1));
		swapMuxSelectMuxInput[2].add(owner.constant.var(KernelLib.dfeUInt(2), 3));
		swapMuxSelectMuxInput[2].add(owner.constant.var(KernelLib.dfeUInt(2), 2));
		swapMuxSelectMuxInput[2].add(owner.constant.var(KernelLib.dfeUInt(2), 0));
		swapMuxSelectMuxInput[3].add(owner.constant.var(KernelLib.dfeUInt(2), 3));
		swapMuxSelectMuxInput[3].add(owner.constant.var(KernelLib.dfeUInt(2), 1));
		swapMuxSelectMuxInput[3].add(owner.constant.var(KernelLib.dfeUInt(2), 0));
		swapMuxSelectMuxInput[3].add(owner.constant.var(KernelLib.dfeUInt(2), 2));

		return swapMuxSelectMuxInput;
	}
}
