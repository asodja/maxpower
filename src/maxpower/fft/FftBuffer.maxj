package maxpower.fft;

import java.util.ArrayList;
import java.util.List;

import maxpower.kernel.mem.Transposer;

import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Params;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.KernelObject;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.KernelType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

/**
 * Containing all buffer used in the fft
 */
public class FftBuffer {

	/**
	 * Creates a buffer to store data between two stages in the fft.
	 *
	 * @param input Data from the previous fft stage.
	 * @param fftSize Size of the fft and by this also size of the buffer.
	 * @param radix Radix of the fft stages connected to the buffer.
	 * @return Data to be feed into the next fft stage.
	 */
	public static <T extends KernelObject<T>> List<T> applyInterStageBuffer(List<T> input, int fftSize, int radix) {
		int numPipes = FftFactory4pipes.NUM_FFT_PIPES;
		int numOutputs = radix;

		KernelLib kernel = input[0].getKernel();
		if (fftSize % (numPipes * numOutputs) != 0) {
			throw new RuntimeException("fftSize must be divisible by both numPipes and numOutputs.");
		}
		int bufferDepth = fftSize / numPipes;

		List<DFEVar> packedInput = packInput(input);
		DFEVector<DFEVar> output;
		final int height = bufferDepth / numOutputs / radix;
		if (height > 0) {
			List<DFEVar> transposedInput = new ArrayList<DFEVar>(numPipes);
			ArrayList<DFEVar> slicedInput = new ArrayList<DFEVar>(numPipes);
			for (int j = 0; j < packedInput.size(); j++) {
				slicedInput.add(packedInput[j]);
			}
			transposedInput.addAll(transpose(slicedInput, numPipes));
			DFEVector<DFEVar> packedData = DFEVectorType.newInstance(transposedInput);
			DFEVectorType<DFEVar> packedType = packedData.getType();

			output = packedType.unpack(Transposer.transpose(packedData.pack(), radix,
					height, numOutputs));
		} else {
			DFEVector<DFEVar> packedData = DFEVectorType.newInstance(packedInput);
			DFEVectorType<DFEVar> packedType = packedData.getType();

			output = packedType.unpack(Transposer.transpose(packedData.pack(),
					bufferDepth / numOutputs, numOutputs));
		}

		DFEVector<DFEVar> offsetOutput = kernel.stream.offset(output, fftSize / numPipes);

		List<DFEVar> transposedOutput = transpose(offsetOutput.getElementsAsList(), numOutputs);

		return unpackOutput(transposedOutput, input[0].getType());
	}

	private static <T extends KernelObject<T>> List<T>transpose(List<T> input, int numOutputs) {
		KernelLib kernel = input[0].getKernel();

		List<DFEVar> packedInput = packInput(input);

		final List<DFEVector<DFEVar>> inputToMux = new ArrayList<DFEVector<DFEVar>>(numOutputs);

		for (int i = 0; i < input.size(); i++) {
			DFEVectorType<DFEVar> arrayType = new DFEVectorType<DFEVar>(packedInput[i].getType(), numOutputs);
			final DFEVector<DFEVar> array = arrayType.newInstance(kernel);
			for (int j = 0; j < numOutputs; j++) {
				array.connect(j, kernel.stream.offset(packedInput[i], j));
			}
			inputToMux.add(kernel.stream.offset(array, -i));
		}
		Params params = kernel.control.count.makeParams(MathUtils.bitsToAddress(input.size()))
				.withMax(input.size());
		DFEVar  select = kernel.control.count.makeCounter(params).getCount();
		final DFEVector<DFEVar> packedOutput = kernel.control.mux(select, inputToMux);

		return unpackOutput(packedOutput, input[0].getType());
	}

	private static <T extends KernelObject<T>> List<DFEVar>packInput(List<T> input) {
		List<DFEVar> packedInput = new ArrayList<DFEVar>(input.size());
		for (int i = 0; i < input.size(); i++) {
			packedInput.add(input[i].pack());
		}
		return packedInput;
	}

	private static <T extends KernelObject<T>> List<T>unpackOutput(DFEVector<DFEVar> packedOutput,
			KernelType<T> type) {
		return unpackOutput(packedOutput.getElementsAsList(), type);
	}

	private static <T extends KernelObject<T>> List<T>unpackOutput(List<DFEVar> packedOutput,
			KernelType<T> type) {
		List<T> output = new ArrayList<T>(packedOutput.size());
		for (int i = 0; i < packedOutput.size(); i++) {
			output.add(type.unpack(packedOutput[i]));
		}
		return output;
	}

	/**
	 * Buffer used to arrange the input data for the fft
	 * Only tested for 4 Pipes and a Radix of 4.
	 * @param input Input data
	 * @param fftSize Size of the fft
	 * @return Data ready to be feed in the first fft stage
	 */
	public static <T extends KernelObject<T>> List<T> applyInputBuffer(List<T> input, final int fftSize) {
		final int numPipes = FftFactory4pipes.NUM_FFT_PIPES;
		KernelLib owner = input[0].getKernel();

		List<DFEVar> packedInput = packInput(input);

		DFEVector<DFEVar> transposerInput = DFEVectorType.newInstance(packedInput);

		DFEVector<DFEVar> transposerResult =
			transposerInput.getType().unpack(Transposer.transpose(transposerInput.pack(),
					fftSize / numPipes / numPipes, numPipes));

		DFEVector<DFEVar> transposerResultOffset = owner.stream.offset(transposerResult, fftSize / numPipes);

		// Now we finish with a small 4 x 4 transpose in the end
		List<DFEVar> outputTranspose = transpose(transposerResultOffset.getElementsAsList(), numPipes);

		return unpackOutput(outputTranspose, input[0].getType());
	}

	/**
	 * Buffer used to rearrange the date between the dual radix 2 stage and the first radix 4 stage
	 * Only tested for 4 Pipes.
	 * @param input Input data
	 * @param fftSize Size of the fft
	 * @return Data ready to be feed in the first fft stage
	 */
	public static <T extends KernelObject<T>> List<T> applyMixedRadixBuffer(List<T> input, final int fftSize) {
		final int numPipes = FftFactory4pipes.NUM_FFT_PIPES;
		KernelLib owner = input[0].getKernel();

		List<DFEVar> packedInput = packInput(input);

		DFEVector<DFEVar> transposerInput = DFEVectorType.newInstance(packedInput);
		DFEVector<DFEVar> transposerResult =
			transposerInput.getType().unpack(Transposer.transpose(transposerInput.pack(),
					fftSize / numPipes / (numPipes / 2), numPipes / 2));

		DFEVector<DFEVar> transposerResultOffset = owner.stream.offset(transposerResult, fftSize / numPipes);

		// Rearrange input a bit
		List<DFEVector<DFEVar>> inputRearranged =
			transpose(convertToTuples(transposerResultOffset.getElementsAsList()), 2);

		DFEVector<DFEVar> transposer2Input = DFEVectorType.newInstance(convertFromTuple(inputRearranged));

		// Do 2D transpose
		DFEVector<DFEVar> transposer2Result =
			transposerInput.getType().unpack(Transposer.transpose(transposer2Input.pack(),
					numPipes / 2, fftSize / numPipes / (numPipes / 2)));

		DFEVector<DFEVar> transposer2ResultOffset = owner.stream.offset(transposer2Result, fftSize / numPipes);

		// Rearrange output

		List<DFEVar> outputList = new ArrayList<DFEVar>();
		outputList.addAll(transposer2ResultOffset.getElementsAsList());

		// Switch element 1 and 2 in List
		DFEVar tmp = outputList[1];
		outputList.set(1, outputList[2]);
		outputList.set(2, tmp);

		return unpackOutput(outputList, input[0].getType());
	}

	private static List<DFEVector<DFEVar>> convertToTuples(List<DFEVar> input) {
		DFEVectorType<DFEVar> twoInputsVectorType = new DFEVectorType<DFEVar>(input[0].getType(), 2);
		List<DFEVector<DFEVar>> data = new ArrayList<DFEVector<DFEVar>>();
		for (int i = 0; i < input.size() / 2; i++) {
			DFEVector<DFEVar> tuppel = twoInputsVectorType.newInstance(input[0].getKernel());
			tuppel[0] <== input[i * 2];
			tuppel[1] <== input[i * 2 + 1];
			data.add(tuppel);
		}
		return data;
	}

	private static List<DFEVar> convertFromTuple(List<DFEVector<DFEVar>> input) {
		List<DFEVar> data = new ArrayList<DFEVar>();
		for (int i = 0; i < input.size(); i++) {
			data.addAll(input[i].getElementsAsList());
		}
		return data;
	}

	/**
	 * Bit reverse the result of the FFT. ATTENTION: This will break for not equal to 4 pipes and non power of 2
	 * input sizes
	 * @param input fft results.
	 * @param fftSize Size of the fft.
	 * @return bit reversed result of the fft.
	 */
	protected static  <T extends KernelObject<T>> List<T> applyBitReverseBuffer(List<T> input, final int fftSize) {
		KernelLib owner = input[0].getKernel();

		DFEVector<DFEVar> packedInput = DFEVectorType.newInstance(packInput(input));

		if (!MathUtils.isPowerOf2(fftSize)) {
			throw new RuntimeException("The bit reverse buffer currently only works for 4 pipes and fft sizes of power of 2");
		}

		final int ramSize = fftSize / FftFactory4pipes.NUM_FFT_PIPES;

		final int N = MathUtils.bitsToAddress(fftSize);

		CounterChain counterChain = owner.control.count.makeCounterChain();
		// if we write in linear order or in our crazy pattern
		DFEVar state       = counterChain.addCounter(2, 1);
		// We have for states that determine rotates, swaps and addresses
		DFEVar bufferState = counterChain.addCounter(4, 1);
		DFEVar position    = counterChain.addCounter(1 << (N - 4), 1);

		ArrayList<Memory<DFEVar>> buffer = new ArrayList<Memory<DFEVar>>();
		for (int i = 0; i < 4; i++) {
			buffer.add(owner.mem.alloc(packedInput[0].getType(), ramSize));
		}

		// First we write to the buffer. We have to rotate buffer state times
		packedInput = packedInput.rotateElementsLeft(bufferState);

		// Now we have to calculate the addresses
		ArrayList<DFEVar> ramAddressUpperBitsMuxInput = getStartingPointsForAddressingBitReverse(owner);
		DFEVar ramAddressUpperBits = owner.control.mux(bufferState, ramAddressUpperBitsMuxInput);

		DFEVar addresses[] = new DFEVar[4];
		for (int i = 0; i < 4; i++) {
			addresses[i] = ramAddressUpperBits + i # bitReverse(position);
			addresses[i] = addresses[i].cast(KernelLib.dfeUInt(2 + N - 4));
		}

		// Now we can finally access the RAM and do some reading and writing
		ArrayList<DFEVar> lookupResults = new ArrayList<DFEVar>();
		DFEVar dataCount = bufferState.cast(KernelLib.dfeUInt(2 + N - 4)) * (1 << (N - 4)) +
				position.cast(KernelLib.dfeUInt(2 + N - 4));
		for (int i = 0; i < 4; i++) {
			DFEVar finalAddress = state ? addresses[i] : dataCount;
			lookupResults.add(buffer[i].read(finalAddress));
			buffer[i].write(finalAddress, packedInput[i], owner.constant.var(true));
		}

		// Now we still have to swap the output a bit
		ArrayList<ArrayList<DFEVar>> swapMuxSelectMuxInput = getMagicNumbersForSwappingBitReverse(owner);

		DFEVector<DFEVar> result = packedInput.getType().newInstance(owner);
		for (int i = 0; i < 4; i++) {
			DFEVar swapMuxSelect = owner.control.mux(bufferState, swapMuxSelectMuxInput[i]);
			result[i] <== owner.control.mux(swapMuxSelect, lookupResults);
		}

		return unpackOutput(owner.stream.offset(result, ramSize), input[0].getType());
	}

	/**
	 * Function to reverse the bits of a given DFEVar.
	 * @param x DFEVar to revert the bits of.
	 * @return Bit reversed DFEVar
	 */
	private static DFEVar bitReverse(DFEVar x) {
		DFEVar result = x.slice(0);

		for (int i = 1; i < x.getType().getTotalBits(); i++) {
			result = result # x.slice(i);
		}

		return result.cast(x.getType());
	}

	private static ArrayList<DFEVar> getStartingPointsForAddressingBitReverse(KernelLib owner) {
		ArrayList<DFEVar> ramAddressUpperBitsMuxInput = new ArrayList<DFEVar>();
		ramAddressUpperBitsMuxInput.add(owner.constant.var(KernelLib.dfeUInt(2), 0));
		ramAddressUpperBitsMuxInput.add(owner.constant.var(KernelLib.dfeUInt(2), 2));
		ramAddressUpperBitsMuxInput.add(owner.constant.var(KernelLib.dfeUInt(2), 3));
		ramAddressUpperBitsMuxInput.add(owner.constant.var(KernelLib.dfeUInt(2), 1));
		return ramAddressUpperBitsMuxInput;
	}

	private static ArrayList<ArrayList<DFEVar>> getMagicNumbersForSwappingBitReverse(KernelLib owner) {
		ArrayList<ArrayList<DFEVar>> swapMuxSelectMuxInput = new ArrayList<ArrayList<DFEVar>>();
		for (int i = 0; i < 4; i++) {
			swapMuxSelectMuxInput.add(new ArrayList<DFEVar>());
		}
		swapMuxSelectMuxInput[0].add(owner.constant.var(KernelLib.dfeUInt(2), 0));
		swapMuxSelectMuxInput[0].add(owner.constant.var(KernelLib.dfeUInt(2), 2));
		swapMuxSelectMuxInput[0].add(owner.constant.var(KernelLib.dfeUInt(2), 1));
		swapMuxSelectMuxInput[0].add(owner.constant.var(KernelLib.dfeUInt(2), 3));
		swapMuxSelectMuxInput[1].add(owner.constant.var(KernelLib.dfeUInt(2), 2));
		swapMuxSelectMuxInput[1].add(owner.constant.var(KernelLib.dfeUInt(2), 0));
		swapMuxSelectMuxInput[1].add(owner.constant.var(KernelLib.dfeUInt(2), 3));
		swapMuxSelectMuxInput[1].add(owner.constant.var(KernelLib.dfeUInt(2), 1));
		swapMuxSelectMuxInput[2].add(owner.constant.var(KernelLib.dfeUInt(2), 1));
		swapMuxSelectMuxInput[2].add(owner.constant.var(KernelLib.dfeUInt(2), 3));
		swapMuxSelectMuxInput[2].add(owner.constant.var(KernelLib.dfeUInt(2), 2));
		swapMuxSelectMuxInput[2].add(owner.constant.var(KernelLib.dfeUInt(2), 0));
		swapMuxSelectMuxInput[3].add(owner.constant.var(KernelLib.dfeUInt(2), 3));
		swapMuxSelectMuxInput[3].add(owner.constant.var(KernelLib.dfeUInt(2), 1));
		swapMuxSelectMuxInput[3].add(owner.constant.var(KernelLib.dfeUInt(2), 0));
		swapMuxSelectMuxInput[3].add(owner.constant.var(KernelLib.dfeUInt(2), 2));

		return swapMuxSelectMuxInput;
	}
}
