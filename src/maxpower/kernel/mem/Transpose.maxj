package maxpower.kernel.mem;

import java.util.ArrayList;
import java.util.List;

import maxpower.kernel.arithmetic.ConstDenominator;
import maxpower.kernel.arithmetic.ConstDenominator.ConstDivModResult;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.Optimization;
import com.maxeler.maxcompiler.v2.kernelcompiler.op_management.MathOps;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Stream.OffsetExpr;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

/**
 * Use single buffer to transpose matrices.
 *
 * @author Stephen Girdlestone
 * @author Nils Voss
 */
public class Transpose {

	private static int offset_counter = 0;

	/**
	 * Multi pipe version of the 2D transpose function. Note that hight and width have to be multiples of
	 * the number of pipes
	 *
	 * Example:
	 * Assume width of 4 and height of 3, with values
	 *
	 * <table>
	 *   <col width="25%"/>
	 *   <col width="25%"/>
	 *   <col width="25%"/>
	 *   <col width="25%"/>
	 *   <tbody>
	 *     <tr><td>0</td><td>1</td><td>2</td><td>3</td></tr>
	 *     <tr><td>4</td><td>5</td><td>6</td><td>7</td></tr>
	 *     <tr><td>8</td><td>9</td><td>10</td><td>11</td></tr>
	 *   </tbody>
	 * </table>
	 *
	 *	Then the output will return (after 12 cycles since the output does not hide the latency)
	 *		0, 4, 8, 1, 5, 9, 2, 6, 10, 3, 7, 11
	 *
	 * width     fast dimension
	 * height    slow dimension
	 **/
	public static DFEVector<DFEVar> transpose(DFEVector<DFEVar> in, int width, int height) {
		return in.getKernel().stream.offset(transpose(in, width, height, in.getKernel().constant.var(true)),
				width * height / in.getSize());
	}

	/**
	 * Multi pipe version of the 2D transpose function. Note that hight and width have to be multiples of
	 * the number of pipes
	 *
	 * Example:
	 * Assume width of 4 and height of 3, with values
	 *
	 * <table>
	 *   <col width="25%"/>
	 *   <col width="25%"/>
	 *   <col width="25%"/>
	 *   <col width="25%"/>
	 *   <tbody>
	 *     <tr><td>0</td><td>1</td><td>2</td><td>3</td></tr>
	 *     <tr><td>4</td><td>5</td><td>6</td><td>7</td></tr>
	 *     <tr><td>8</td><td>9</td><td>10</td><td>11</td></tr>
	 *   </tbody>
	 * </table>
	 *
	 *	Then the output will return (after 12 cycles since the output does not hide the latency)
	 *		0, 4, 8, 1, 5, 9, 2, 6, 10, 3, 7, 11
	 *
	 * width     fast dimension
	 * height    slow dimension
	 **/
	public static DFEVector<DFEVar> transpose(DFEVector<DFEVar> in, int width, int height, DFEVar enable) {
		KernelLib owner = in.getKernel();

		final int N = width * height;
		final int pipes = in.getSize();
		if (!MathUtils.integerMultiple(width, pipes) || !MathUtils.integerMultiple(height, pipes)) {
			throw new RuntimeException("Width and height have to be a multiple of the number of pipes.");
		}
		if (pipes == 1) { // Use more efficient single buffered version
			return in.getType().newInstance(owner, transpose(in[0], width, height, enable));
		}

		DFEVector<DFEVar> result;
		if (height == width && height >= 2 * pipes && height % pipes == 0 && MathUtils.isPowerOf2(pipes)) {
			// Single buffered implementation for special case
			int ramSize = N / pipes;

			int nByPipes = width / pipes;
			DFEType dataType = in[0].getType();
			DFEVectorType<DFEVar> vectorType = new DFEVectorType<DFEVar>(dataType, pipes);
			DFEVectorType<DFEVar> bufferOutVectorType = new DFEVectorType<DFEVar>(dataType, pipes);
			DFEVectorType<DFEVar> addressType =
				new DFEVectorType<DFEVar>(Kernel.dfeUInt(MathUtils.bitsToAddress(ramSize)), pipes);
			DFEVector<DFEVar> ramReadAddress = addressType.newInstance(owner);

			CounterChain counterChainRow = owner.control.count.makeCounterChain(enable);
			CounterChain counterChainCol = owner.control.count.makeCounterChain(enable);

			DFEVar state = counterChainRow.addCounter(2, 1);
			DFEVar row_j = counterChainRow.addCounter(height, 1);
			DFEVar row_i = counterChainRow.addCounter(width / pipes, 1);
			DFEVar col_j = counterChainCol.addCounter(width, 1);
			DFEVar col_i = counterChainCol.addCounter(height, pipes);

			int bitsToAddressPipes = MathUtils.bitsToAddress(pipes);
			DFEVar shift_write = row_j.slice(0, bitsToAddressPipes).cast(Kernel.dfeUInt(bitsToAddressPipes));
			DFEVar shift_read  = col_j.slice(0, bitsToAddressPipes).cast(Kernel.dfeUInt(bitsToAddressPipes));

			owner.optimization.pushFixOpMode(Optimization.bitSizeExact(MathUtils.bitsToAddress(ramSize)),
					Optimization.offsetExact(0), MathOps.ALL);
			DFEVar ramWriteAddress = row_j * nByPipes + row_i.cast(row_j.getType());
			for(int i = 0; i < pipes; i++){
				ramReadAddress[i] <== (col_i + i) * nByPipes + (col_j >> bitsToAddressPipes);
			}
			owner.optimization.popFixOpMode(MathOps.ALL);

			DFEVector<DFEVar> inputRotated =
				in.rotateElementsLeft(shift_write.cast(Kernel.dfeUInt(bitsToAddressPipes)));
			DFEVector<DFEVar> readAddrRotated = ramReadAddress.rotateElementsLeft(shift_read);

			DFEVector<DFEVar> bufferOutput = bufferOutVectorType.newInstance(owner);
			for(int i = 0; i < pipes; i++){
				Memory<DFEVar> buffer = owner.mem.alloc(vectorType.getContainedType(), ramSize);
				DFEVar address = state ? readAddrRotated[i] : ramWriteAddress;
				bufferOutput[i] <== buffer.read(address);
				buffer.write(address, inputRotated[i], enable);
			}
			result = bufferOutput.rotateElementsRight(shift_read);
		} else {
			// double buffered implementation
			final int ramSize = 2 * N / pipes;

			DFEType addressType = Kernel.dfeUInt(MathUtils.bitsToAddress(ramSize));
			CounterChain readCounter = owner.control.count.makeCounterChain(enable);
			CounterChain writeCounter = owner.control.count.makeCounterChain(enable);

			DFEVar state    = readCounter.addCounter(2,              1);
			DFEVar slowRead = readCounter.addCounter(width,          1).cast(addressType);
			DFEVar fastRead = readCounter.addCounter(height / pipes, 1).cast(addressType);

			DFEVar slowWrite = writeCounter.addCounter(height, 1).cast(addressType);
			                   writeCounter.addCounter(width / pipes, 1).setReportOnUnused(false);

			DFEVar writeAddress = owner.control.count.simpleCounter(MathUtils.bitsToAddress(ramSize), N / pipes);

			ConstDivModResult readRotateDivMod = ConstDenominator.divMod(slowRead, pipes);
			DFEVar group = readRotateDivMod.getQuotient();
			DFEVar readRotate = readRotateDivMod.getRemainder();
			DFEVar writeRotate;
			if (width != height) {
				ConstDivModResult writeRotateDivMod = ConstDenominator.divMod(slowWrite, pipes);
				writeRotateDivMod.getQuotient().setReportOnUnused(false);
				writeRotate = writeRotateDivMod.getRemainder();
			} else {
				slowWrite.setReportOnUnused(false);
				writeRotate = readRotate;
			}

			writeAddress = state ? writeAddress : (writeAddress + (N / pipes));

			DFEVector<DFEVar> readAddresses = new DFEVectorType<DFEVar>(addressType, pipes).newInstance(owner);
			DFEVar readAddressOffset = fastRead.cast(addressType) * width + group.cast(addressType);
			for (int i = 0; i < pipes; i++) {
				DFEVar readAddress = readAddressOffset + i * (width / pipes);
				readAddresses[i] <== state ? readAddress + N / pipes : readAddress;
			}
			readAddresses = readAddresses.rotateElementsLeft(readRotate);

			DFEVector<DFEVar> inRotated = in.rotateElementsLeft(writeRotate);

			List<DFEVar> lookupResults = new ArrayList<DFEVar>();
			for (int i = 0; i < in.getSize(); i++) {
				Memory<DFEVar> buffer = owner.mem.alloc(inRotated[i].getType(), ramSize);
				buffer.write(writeAddress, inRotated[i], enable);
				lookupResults.add(buffer.read(readAddresses[i]));
			}

			result = DFEVectorType.newInstance(lookupResults);
			result = result.rotateElementsRight(readRotate);
		}
		return result;
	}

	/**
	 * For minimal resource usage, choose width and height such that
	 * (width*height-1) is an exact power of two.
	 *
	 * Note that you must have width*height>=17
	 *
	 * Example:
	 * Assume width of 4 and height of 3, with values
	 *
	 * <table>
	 *   <col width="25%"/>
	 *   <col width="25%"/>
	 *   <col width="25%"/>
	 *   <col width="25%"/>
	 *   <tbody>
	 *     <tr><td>0</td><td>1</td><td>2</td><td>3</td></tr>
	 *     <tr><td>4</td><td>5</td><td>6</td><td>7</td></tr>
	 *     <tr><td>8</td><td>9</td><td>10</td><td>11</td></tr>
	 *   </tbody>
	 * </table>
	 *
	 *	Then the output will return (after 12 cycles since the output does not hide the latency)
	 *		0, 4, 8, 1, 5, 9, 2, 6, 10, 3, 7, 11
	 *
	 * width     fast dimension
	 * height    slow dimension
	 **/
	public static DFEVar transpose(DFEVar in, int width, int height) {
		return in.getKernel().stream.offset(
				transpose(in, width, height, in.getKernel().constant.var(true)), width * height);
	}

	/**
	 * For minimal resource usage, choose width and height such that
	 * (width*height-1) is an exact power of two.
	 *
	 * Note that you must have width*height>=17
	 *
	 * Example:
	 * Assume width of 4 and height of 3, with values
	 *
	 * <table>
	 *   <col width="25%"/>
	 *   <col width="25%"/>
	 *   <col width="25%"/>
	 *   <col width="25%"/>
	 *   <tbody>
	 *     <tr><td>0</td><td>1</td><td>2</td><td>3</td></tr>
	 *     <tr><td>4</td><td>5</td><td>6</td><td>7</td></tr>
	 *     <tr><td>8</td><td>9</td><td>10</td><td>11</td></tr>
	 *   </tbody>
	 * </table>
	 *
	 *	Then the output will return (after 12 cycles since the output does not hide the latency)
	 *		0, 4, 8, 1, 5, 9, 2, 6, 10, 3, 7, 11
	 *
	 * width     fast dimension
	 * height    slow dimension
	 **/
	public static DFEVar transpose(DFEVar in, int width, int height, DFEVar enable) {
		KernelLib owner = in.getKernel();

		int N = width * height;

		int Nm = N - 1;
		int nBits = MathUtils.bitsToAddress(N);

		DFEVar isFirst = owner.control.count.pulse(1);

		DFEVar i = owner.control.count.makeCounter(
				owner.control.count.makeParams(nBits).withEnable(enable).withMax(N)).getCount();
		DFEVar mul = Kernel.dfeUInt(nBits).newInstance(owner);
		owner.optimization.pushEnableBitGrowth(true);
		ConstDivModResult addressDivMod = ConstDenominator.divMod(i * mul, Nm, nBits);
		addressDivMod.getQuotient().setReportOnUnused(false);
		DFEVar address = i === Nm ? Nm : addressDivMod.getRemainder();

		DFEVar nextMul = mul * Kernel.dfeUInt(MathUtils.bitsToRepresent(width)).newInstance(owner, width);
		owner.optimization.popEnableBitGrowth();

		ConstDivModResult nextMulDivMod = ConstDenominator.divMod(nextMul, Nm, nBits);
		nextMulDivMod.getQuotient().setReportOnUnused(false);
		nextMul = nextMulDivMod.getRemainder();

		OffsetExpr offset = owner.stream.makeOffsetAutoLoop("transposerOffset" + offset_counter++, 0, N);
		mul <== owner.control.mux(isFirst#(i===0), owner.stream.offset(mul, -1),
				owner.stream.offset(nextMul, -offset), owner.constant.var(1), owner.constant.var(1));

		DFEVar writeAddress = address;
		DFEVar readAddress = address;

		owner.getManager().logInfo("Depth of RAM in Transposer = " + N);

		Memory<DFEVar> buffer = owner.mem.alloc(in.getType(), N);
		buffer.write(writeAddress, in, enable);

		return buffer.read(readAddress);
	}
}
