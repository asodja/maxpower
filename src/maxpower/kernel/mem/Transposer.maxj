package maxpower.kernel.mem;

import java.util.ArrayList;
import java.util.List;

import maxpower.kernel.arithmetic.ConstDenominator;
import maxpower.kernel.arithmetic.ConstDenominator.ConstDivModResult;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Stream.OffsetExpr;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

/**
 * Use single buffer to transpose matrices.
 */
public class Transposer {

	private static int offset_counter = 0;

	/**
	 * Multi pipe version of the 2D transpose function. Note that hight and width have to be multiples of
	 * the number of pipes
	 *
	 * Example:
	 * Assume width of 4 and height of 3, with values
	 *
	 *	0	|	1	|	2	|	3
	 *	4	|	5	|	6	|	7
	 *	8	|	9	|	10	|	11
	 *
	 *	Then the output will return (after 12 cycles since the output does not hide the latency)
	 *		0, 4, 8, 1, 5, 9, 2, 6, 10, 3, 7, 11
	 *
	 * width     fast dimension
	 * height    slow dimension
	 **/
	public static DFEVector<DFEVar> transpose(DFEVector<DFEVar> in, int width, int height) {
		return in.getKernel().stream.offset(transpose(in, width, height, in.getKernel().constant.var(true)),
				width * height / in.getSize());
	}

	/**
	 * Multi pipe version of the 2D transpose function. Note that hight and width have to be multiples of
	 * the number of pipes
	 *
	 * Example:
	 * Assume width of 4 and height of 3, with values
	 *
	 *	0	|	1	|	2	|	3
	 *	4	|	5	|	6	|	7
	 *	8	|	9	|	10	|	11
	 *
	 *	Then the output will return (after 12 cycles since the output does not hide the latency)
	 *		0, 4, 8, 1, 5, 9, 2, 6, 10, 3, 7, 11
	 *
	 * width     fast dimension
	 * height    slow dimension
	 **/
	public static DFEVector<DFEVar> transpose(DFEVector<DFEVar> in, int width, int height, DFEVar enable) {
		KernelLib owner = in.getKernel();

		final int N = width * height;
		final int pipes = in.getSize();
		final int ramSize = 2 * N / pipes;
		if (!MathUtils.integerMultiple(width, pipes) || !MathUtils.integerMultiple(height, pipes)) {
			throw new RuntimeException("Width and height have to be a multiple of the number of pipes.");
		}
		if (pipes == 1) { // Use more efficient single buffered version
			return in.getType().newInstance(owner, transpose(in[0], width, height, enable));
		}
		// double buffered implementation

		DFEType addressType = Kernel.dfeUInt(MathUtils.bitsToAddress(ramSize));
		System.out.println(MathUtils.bitsToAddress(ramSize));
		CounterChain readCounter = owner.control.count.makeCounterChain(enable);
		CounterChain writeCounter = owner.control.count.makeCounterChain(enable);

		DFEVar state    = readCounter.addCounter(2,              1);
		DFEVar slowRead = readCounter.addCounter(width,          1).cast(addressType);
		DFEVar fastRead = readCounter.addCounter(height / pipes, 1).cast(addressType);

		DFEVar slowWrite = writeCounter.addCounter(height, 1).cast(addressType);
		                   writeCounter.addCounter(width / pipes, 1).setReportOnUnused(false);

		DFEVar writeAddress = owner.control.count.simpleCounter(MathUtils.bitsToAddress(ramSize), N / pipes);

		ConstDivModResult readRotateDivMod = ConstDenominator.divMod(slowRead, pipes);
		DFEVar group = readRotateDivMod.getQuotient();
		DFEVar readRotate = readRotateDivMod.getRemainder();
		DFEVar writeRotate;
		if (width != height) {
			ConstDivModResult writeRotateDivMod = ConstDenominator.divMod(slowWrite, pipes);
			writeRotateDivMod.getQuotient().setReportOnUnused(false);
			writeRotate = writeRotateDivMod.getRemainder();
		} else {
			writeRotate = readRotate;
		}

		writeAddress = state ? writeAddress : (writeAddress + (N / pipes));

		DFEVector<DFEVar> readAddresses = new DFEVectorType<DFEVar>(addressType, pipes).newInstance(owner);
		DFEVar readAddressOffset = fastRead.cast(addressType) * width + group.cast(addressType);
		for (int i = 0; i < pipes; i++) {
			DFEVar readAddress = readAddressOffset + i * (width / pipes);
			readAddresses[i] <== state ? readAddress + N / pipes : readAddress;
		}
		readAddresses = readAddresses.rotateElementsLeft(readRotate);

		DFEVector<DFEVar> inRotated = in.rotateElementsLeft(writeRotate);

		List<DFEVar> lookupResults = new ArrayList<DFEVar>();
		for (int i = 0; i < in.getSize(); i++) {
			Memory<DFEVar> buffer = owner.mem.alloc(inRotated[i].getType(), ramSize);
			buffer.write(writeAddress, inRotated[i], enable);
			lookupResults.add(buffer.read(readAddresses[i]));
		}

		DFEVector<DFEVar> result = DFEVectorType.newInstance(lookupResults);
		return result.rotateElementsRight(readRotate);
	}

	/**
	 * For minimal resource usage, choose width and height such that
	 * (width*height-1) is an exact power of two.
	 *
	 * Note that you must have width*height>=17
	 *
	 * Example:
	 * Assume width of 4 and height of 3, with values
	 *
	 *	0	|	1	|	2	|	3
	 *	4	|	5	|	6	|	7
	 *	8	|	9	|	10	|	11
	 *
	 *	Then the output will return (after 12 cycles since the output does not hide the latency)
	 *		0, 4, 8, 1, 5, 9, 2, 6, 10, 3, 7, 11
	 *
	 * width     fast dimension
	 * height    slow dimension
	 **/
	public static DFEVar transpose(DFEVar in, int width, int height) {
		return in.getKernel().stream.offset(
				transpose(in, width, 1, height, in.getKernel().constant.var(true)), width * height);
	}

	/**
	 * For minimal resource usage, choose width and height such that
	 * (width*height-1) is an exact power of two.
	 *
	 * Note that you must have width*height>=17
	 *
	 * Example:
	 * Assume width of 4 and height of 3, with values
	 *
	 *	0	|	1	|	2	|	3
	 *	4	|	5	|	6	|	7
	 *	8	|	9	|	10	|	11
	 *
	 *	Then the output will return (after 12 cycles since the output does not hide the latency)
	 *		0, 4, 8, 1, 5, 9, 2, 6, 10, 3, 7, 11
	 *
	 * width     fast dimension
	 * height    slow dimension
	 **/
	public static DFEVar transpose(DFEVar in, int width, int height, DFEVar enable) {
		return transpose(in, width, 1, height, enable);
	}

	/**
	 * This one differs from constructor Transposer(DFEVar in, int width, int height) in that
	 * movement in the horizontal directions, when transposing, are not by one column but by a user defined amount.
	 *
	 * Example:
	 * Assume width (fast) of 5 and height (medium) of 3 and depth (slow) of 2, with values
	 *
	 *	0	|	1	|	2	|	3	|	4
	 *	10	|	11	|	12	|	13	|	14
	 *	20	|	21	|	22	|	23	|	24
	 *
	 *	5	|	6	|	7	|	8	|	9
	 *	15	|	16	|	17	|	18	|	19
	 *	25	|	26	|	27	|	28	|	29
	 *
	 *	Then the output will return
	 *		0, 5, 10, 15, 20, 25, 1, 6, 11, 16, ...
	 *
	 * width     fast dimension
	 * height    medium dimension
	 * depth     slow dimension
	 **/
	public static DFEVar transpose(DFEVar in, int width, int height, int depth) {
		return in.getKernel().stream.offset(
				transpose(in, width, height, depth, in.getKernel().constant.var(true)),
				width * height * depth);
	}

	/**
	 * This one differs from constructor Transposer(DFEVar in, int width, int height, DFEVar enable) in that
	 * movement in the horizontal directions, when transposing, are not by one column but by a user defined amount.
	 *
	 * Example:
	 * Assume width (fast) of 5 and height (medium) of 3 and depth (slow) of 2, with values
	 *
	 *	0	|	1	|	2	|	3	|	4
	 *	5	|	6	|	7	|	8	|	9
	 *	10	|	11	|	12	|	13	|	14
	 *
	 *	15	|	16	|	17	|	18	|	19
	 *	20	|	21	|	22	|	23	|	24
	 *	25	|	26	|	27	|	28	|	29
	 *
	 *	Then the output will return
	 *		0, 15, 5, 20, 10, 25, 1, 16, 6, 21, ...
	 *
	 * width     fast dimension
	 * height    medium dimension
	 * depth     slow dimension
	 **/
	public static DFEVar transpose(DFEVar in, int width, int height, int depth, DFEVar enable) {
		KernelLib owner = in.getKernel();

		int N = width * height * depth;
		boolean isDoubleBuffered;

		DFEVar writeAddress;
		DFEVar readAddress;

		if (height == 1) {
			isDoubleBuffered = false;

			int Nm = N - 1;
			int nBits = MathUtils.bitsToAddress(N);

			DFEVar isFirst = owner.control.count.pulse(1);

			DFEVar i = owner.control.count.makeCounter(
					owner.control.count.makeParams(nBits).withEnable(enable).withMax(N)).getCount();
			DFEVar mul = Kernel.dfeUInt(nBits).newInstance(owner);
			owner.optimization.pushEnableBitGrowth(true);
			ConstDivModResult addressDivMod = ConstDenominator.divMod(i * mul, Nm, nBits);
			addressDivMod.getQuotient().setReportOnUnused(false);
			DFEVar address = i === Nm ? Nm : addressDivMod.getRemainder();

			DFEVar nextMul = mul * Kernel.dfeUInt(MathUtils.bitsToRepresent(width)).newInstance(owner, width);
			owner.optimization.popEnableBitGrowth();

			ConstDivModResult nextMulDivMod = ConstDenominator.divMod(nextMul, Nm, nBits);
			nextMulDivMod.getQuotient().setReportOnUnused(false);
			nextMul = nextMulDivMod.getRemainder();

			OffsetExpr offset = owner.stream.makeOffsetAutoLoop("transposerOffset" + offset_counter++, 0, N);
			mul <== owner.control.mux(isFirst#(i===0), owner.stream.offset(mul, -1),
					owner.stream.offset(nextMul, -offset), owner.constant.var(1), owner.constant.var(1));

			writeAddress = address;
			readAddress = address;

			owner.getManager().logInfo("Depth of RAM in Transposer = " + N);
		} else if (width == depth) {
			isDoubleBuffered = false;

			DFEType addressType = Kernel.dfeUInt(MathUtils.bitsToAddress(N));

			CounterChain readCounter = owner.control.count.makeCounterChain(enable);

			DFEVar changePattern = readCounter.addCounter(2,      1);
			DFEVar slow          = readCounter.addCounter(width,  1).cast(addressType);
			DFEVar medium        = readCounter.addCounter(height, 1).cast(addressType);
			DFEVar fast          = readCounter.addCounter(depth,  1).cast(addressType);

			DFEVar cycleCounter = owner.control.count.simpleCounter(MathUtils.bitsToAddress(N), N);

			DFEVar address = changePattern === 0 ? cycleCounter :
					(fast * height + medium) * width + slow;

			writeAddress = address;
			readAddress = address;
		} else {
			// double buffered implementation
			isDoubleBuffered = true;

			DFEType calculationType = Kernel.dfeUInt(MathUtils.bitsToAddress(N));
			DFEType addressType = Kernel.dfeUInt(MathUtils.bitsToAddress(2 * N));
			CounterChain readCounter = owner.control.count.makeCounterChain(enable);
			CounterChain writeCounter = owner.control.count.makeCounterChain(enable);

			DFEVar rdBuff = readCounter.addCounter(2,      1);
			DFEVar slow   = readCounter.addCounter(width,  1).cast(calculationType);
			DFEVar medium = readCounter.addCounter(height, 1).cast(calculationType);
			DFEVar fast   = readCounter.addCounter(depth,  1).cast(calculationType);

			readAddress  = fast * width * height + medium * width + slow;
			writeAddress = writeCounter.addCounter(N, 1).cast(calculationType);

			writeAddress = writeAddress.cat(rdBuff).cast(addressType);
			readAddress  = readAddress.cat(~rdBuff).cast(addressType);
		}

		int ramSize = isDoubleBuffered ? 2 * N : N;

		Memory<DFEVar> buffer = owner.mem.alloc(in.getType(), ramSize);
		buffer.write(writeAddress, in, enable);

		return buffer.read(readAddress);
	}
}
