package maxpower.kernel.sort;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;

/**
 * Class providing simple interfaces to sort DFEVars using bitonic sort
 * @author nvoss
 *
 */
public class BitonicSort {

	/**
	 * Sorts DFEVars
	 * @param size Number of DFEVars to sort (has to be a power of 2)
	 * @param input DFEVars to sort
	 * @return Sorted DFEVars
	 */
	public static List<DFEVar> sort(final int size, DFEVar... input) {
		return sort(size, Arrays.asList(input));
	}

	/**
	 * Sorts DFEVars
	 * @param size Number of DFEVars to sort (has to be a power of 2)
	 * @param input DFEVars to sort
	 * @return Sorted DFEVars
	 */
	public static List<DFEVar> sort(final int size, DFEVector<DFEVar> input) {
		List<DFEVar> inputAsList = new ArrayList<DFEVar>();
		for (int i = 0; i < size; i++) {
			inputAsList.add(input[i]);
		}
		return sort(size, inputAsList);
	}

	/**
	 * Sorts DFEVars
	 * @param size Number of DFEVars to sort (has to be a power of 2)
	 * @param input DFEVars to sort
	 * @return Sorted DFEVars
	 */
	public static List<DFEVar> sort(final int size, List<DFEVar> input) {
		if (!checkPowerOf2(size)) {
			throw new RuntimeException("Numbers of values to sort has to be a power of 2!");
		}
		if (input.size() != size) {
			throw new RuntimeException("Size of List must match number of values to sort!");
		}

		return bitonicSort(true, input);
	}

	private static List<DFEVar> bitonicSort(boolean up, List<DFEVar> input) {
		if (input.size() == 1) {
			return input;
		} else {
			List<DFEVar> firstHalf   = bitonicSort(true,  input.subList(0, input.size() / 2));
			List<DFEVar> secondeHalf = bitonicSort(false, input.subList(input.size() / 2, input.size()));
			List<DFEVar> combined = new ArrayList<DFEVar>(firstHalf);
			combined.addAll(secondeHalf);
			return bitonicMerge(up, combined);
		}
	}

	private static List<DFEVar> bitonicMerge(boolean up, List<DFEVar> input) {
		if (input.size() == 1) {
			return input;
		} else {
			bitonicCompare(up, input);
			List<DFEVar> firstHalf   = bitonicMerge(up, input.subList(0, input.size() / 2));
			List<DFEVar> secondeHalf = bitonicMerge(up, input.subList(input.size() / 2, input.size()));
			List<DFEVar> combined = new ArrayList<DFEVar>(firstHalf);
			combined.addAll(secondeHalf);
			return combined;
		}
	}

	private static void bitonicCompare(boolean up, List<DFEVar> input) {
		int distance = input.size() / 2;

		for (int i = 0; i < distance; i++) {
			DFEVar change;
			if (up == true) {
				change = input.get(i) > input.get(i + distance);
			} else {
				change = input.get(i) < input.get(i + distance);
			}
			DFEVar tmp = input.get(i);
			input.set(i, change ? input.get(i + distance) : input.get(i));
			input.set(i + distance, change ? tmp : input.get(i + distance));
		}
	}

	private static boolean checkPowerOf2(final int size) {
		if (size == 1) {
			return true;
		}
		if (size % 2 == 0) {
			return checkPowerOf2(size / 2);
		} else {
			return false;
		}
	}
}
