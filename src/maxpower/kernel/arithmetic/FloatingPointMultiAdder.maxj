package maxpower.kernel.arithmetic;

import static com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFETypeFactory.dfeBool;
import static com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFETypeFactory.dfeFix;
import static com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFETypeFactory.dfeFixOffset;
import static com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFETypeFactory.dfeInt;
import static com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFETypeFactory.dfeUInt;
import static com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStructType.sft;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import maxpower.kernel.KernelBinaryOp.Max;
import maxpower.kernel.pipeline.FanoutLimiter;
import maxpower.ops.AssociativeOp;
import maxpower.utils.TreeReduce;

import com.maxeler.maxcompiler.v2.errors.MaxCompilerAPIError;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.SMIO;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.FloatingPoint;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.KernelMath;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEFix;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEFix.SignMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEFloat;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStruct;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStructType;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmInput;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmOutput;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmValue;
import com.maxeler.maxcompiler.v2.statemachine.kernel.KernelStateMachine;
import com.maxeler.maxcompiler.v2.statemachine.types.DFEsmValueType;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

/**
 * Add several floating-point numbers, without de-normalizing and re-normalizing the intermediate results,
 * thus saving resources.
 * <p>
 * N.B. The addition will be performed in a binary tree, which may slightly effect the final result, due
 * to the altered order of the additions (floating-point addition is not strictly associative).
 */
public class FloatingPointMultiAdder {
	public static final int DEFAULT_NUM_GUARD_BITS = 1;

	/**
	 * Sum values using the default number of guard bits.
	 */
	public static DFEVar add(DFEVar... summands) {
		return add(Arrays.asList(summands));
	}

	/**
	 * Sum values using the default number of guard bits.
	 */
	public static DFEVar add(List<DFEVar> summands) {
		return add(DEFAULT_NUM_GUARD_BITS, summands);
	}

	/**
	 * Sum values using the specified number of guard bits.
	 * <p>
	 * N.B. Increasing the number of guards bits may decrease the numerical error
	 * from rounding, but may also increase the resource usage on the DFE.
	 *
	 * @param numGuardBits  Number of extra bits used during summation to improve precision.
	 * @param summands      Values to sum.
	 */
	public static DFEVar add(int numGuardBits, DFEVar... summands) {
		return add(numGuardBits, Arrays.asList(summands));
	}

	/**
	 * Sum values using the specified number of guard bits.
	 * <p>
	 * N.B. Increasing the number of guards bits may decrease the numerical error
	 * from rounding, but may also increase the resource usage on the DFE. If the
	 * number of summands is 2 then this will use the regular floating point addition
	 * instead. In this case it is advisable to use a pipelining factor of 0.5 on
	 * MAX4 and 0.8 on MAX3.
	 *
	 * @param numGuardBits  Number of extra bits used during summation to improve precision.
	 * @param summands      Values to sum.
	 */
	public static DFEVar add(int numGuardBits, List<DFEVar> summands) {
		switch (summands.size()) {
		case 0: throw new MaxCompilerAPIError("Must have at least one float.");
		case 1: return summands[0];
		case 2: return summands[0] + summands[1];
		}

		if (!(summands[0].getType() instanceof DFEFloat)) {
			throw new RuntimeException("FloatingPointMultiAdder only supports floating point values. For fixed point addition use TreeReduce.");
		}

		checkTypesIdentical(summands);

		KernelLib owner = summands[0].getKernel();
		DFEFloat  type  = (DFEFloat) summands[0].getType();

		FanoutLimiter<DFEVar> maxExponent = getMaxExponent(summands);

		List<DFEStruct> treeValues = getReductionInputs(numGuardBits, summands, maxExponent);

		DFEStruct sum = TreeReduce.reduce(new CondAddSubWithBitGrowth(), treeValues);
		DFEVar sumNeg = sum["neg"];
		DFEVar sumVal = sum["val"];

		DFEVar sumFlt = sumVal.cast(type);
		// fix sign
		owner.optimization.pushPipeliningFactor(0);
		sumFlt = ((FloatingPoint.getSignBit(sumFlt) ^ sumNeg)
		         # FloatingPoint.getExponentBits(sumFlt)
		         # FloatingPoint.getMantissaBits(sumFlt)).cast(type);
		owner.optimization.popPipeliningFactor();
		// fix exponent and we're done
		DFEVar scale = asSigned(maxExponent.get()) - type.getExponentBias();
		return KernelMath.scalb(sumFlt, scale);
	}

	private static FanoutLimiter<DFEVar> getMaxExponent(List<DFEVar> summands) {
		KernelLib owner = summands[0].getKernel();

		List<DFEVar> exponents = new ArrayList<DFEVar>();
		for (DFEVar summand : summands) {
			exponents.add(getExponent(summand));
		}

		// TODO Is this too conservative?
		int fanoutLimit = 8 + (int)((1 - owner.optimization.getPipeliningFactor()) * 8);
		return new FanoutLimiter<DFEVar>(TreeReduce.reduce(new Max(), exponents), fanoutLimit);
	}

	private static DFEVar getSign(DFEVar val) {
		return FloatingPoint.getSignBit(val).cast(dfeUInt(1));
	}

	private static DFEVar getExponent(DFEVar val) {
		int numExponentBits = ((DFEFloat) val.getType()).getExponentBits();
		return FloatingPoint.getExponentBits(val).cast(dfeUInt(numExponentBits));
	}

	// get mantissas with implicit leading 1 and guard bits appended
	private static DFEVar getMantissa(int numGuardBits, DFEVar val) {
		KernelLib owner = val.getKernel();
		DFEVar implicit1 = (getExponent(val) !== 0);
		DFEVar mantissa  = implicit1 # FloatingPoint.getMantissaBits(val);

		if (numGuardBits > 0)
			mantissa = mantissa # owner.constant.zero(dfeUInt(numGuardBits));

		return mantissa.cast(dfeFix(1, mantissa.getType().getTotalBits() - 1, SignMode.UNSIGNED));
	}

	private static DFEVar getShift(DFEVar maxExponent, DFEVar summand, int maxShiftBits) {
		DFEVar expDelta = maxExponent - getExponent(summand);
		DFEVar maxShift = summand.getKernel().constant.var(expDelta.getType(), (1 << maxShiftBits) - 1);
		return KernelMath.min(maxShift, expDelta).cast(dfeUInt(maxShiftBits));
	}

	private static List<DFEStruct> getReductionInputs(int numGuardBits, List<DFEVar> summands, FanoutLimiter<DFEVar> maxExponent) {
		KernelLib owner = summands[0].getKernel();

		List<DFEStruct> redVals = new ArrayList<DFEStruct>();
		for (DFEVar summand : summands) {
			DFEVar mantissa     = getMantissa(numGuardBits, summand);
			int    maxShiftBits = MathUtils.bitsToRepresent(mantissa.getType().getTotalBits());
			DFEVar normalized   = (mantissa >> getShift(maxExponent.get(), summand, maxShiftBits));

			DFEVar redValue = asSigned(normalized); // convert to signed type

			DFEStruct redVal = getReductionType(redValue.getType()).newInstance(owner);
			redVal["neg"] <== getSign(summand);
			redVal["val"] <== redValue;

			redVals.add(redVal);
		}
		return redVals;
	}

	private static DFEVar asSigned(DFEVar v) {
		DFEFix unsignedType = (DFEFix) v.getType();
		DFEFix signedType   = dfeFixOffset(unsignedType.getTotalBits()+1, unsignedType.getOffset(), SignMode.TWOSCOMPLEMENT);
		return v.cast(signedType);
	}

	private static DFEVar reinterpretCast(DFEVar v, DFEType type) {
		return type.unpack(v.pack());
	}

	private static void checkTypesIdentical(List<DFEVar> summands) {
		for (DFEVar summand : summands) {
			if (!summand.getType().equals(summands[0].getType())) {
				throw new MaxCompilerAPIError("All of the floats must have the same type.");
			}
		}
	}

	private static DFEStructType getReductionType(DFEType valueType) {
		return new DFEStructType(sft("neg", dfeBool()), sft("val", valueType));
	}

	// The CondAddSub pass in the compiler does not currently support bit growth.
	// This is temporary workaround until it does.
	private static class CondAddSubWithBitGrowth implements AssociativeOp<DFEStruct> {
		// Implement using state machine so we're not unnecessarily creating extra nodes in graph.
		private static class SM extends KernelStateMachine {
			private final DFEsmInput a, b, aNeg, bNeg;
			private final DFEsmOutput r;

			protected SM(KernelLib owner, int bits) {
				super(owner);

				a    = io.input("a",    dfeInt(bits));
				b    = io.input("b",    dfeInt(bits));
				aNeg = io.input("aNeg", dfeBool());
				bNeg = io.input("bNeg", dfeBool());
				r    = io.output("r",   dfeInt(bits));
			}

			@Override
			protected void outputFunction() {
				DFEsmValue c = aNeg ^ bNeg;
				r <== a + (b ^ mask(c, r.getType())) + c.cast(r.getType());
			}

			private DFEsmValue mask(DFEsmValue c, DFEsmValueType type) {
				DFEsmValue mask = c;
				for (int i = 1; i < type.getTotalBits(); ++i) {
					mask = mask # c;
				}
				return mask.cast(type);
			}

			@Override protected void nextState() {} // there is no state!!
		}

		private static int i = 0;
		@Override
		public DFEStruct op(DFEStruct a, DFEStruct b) {
			DFEVar aNeg = a["neg"];
			DFEVar bNeg = b["neg"];
			DFEVar aVal = a["val"];
			DFEVar bVal = b["val"];

			KernelLib owner = a.getKernel();

			owner.optimization.pushEnableBitGrowth(true);
			DFEVar unusedSum = aVal + bVal;
			unusedSum.setReportOnUnused(false);
			DFEFix rValType = (DFEFix) unusedSum.getType(); // this addition will be optimized away
			// don't grow beyond 64 bits - we cannot cast more than 64bits to float
			if (rValType.getTotalBits() > 64)
				rValType = dfeFixOffset(64, rValType.getOffset(), SignMode.TWOSCOMPLEMENT);
			owner.optimization.popEnableBitGrowth();

			SMIO sm = owner.addStateMachine("CondAddSubSM"+i++, new SM(owner, rValType.getTotalBits()));
			sm.connectInput("a", reinterpretCast(aVal.cast(rValType), dfeInt(rValType.getTotalBits())));
			sm.connectInput("b", reinterpretCast(bVal.cast(rValType), dfeInt(rValType.getTotalBits())));
			sm.connectInput("aNeg", aNeg);
			sm.connectInput("bNeg", bNeg);

			DFEStruct result = getReductionType(rValType).newInstance(a.getKernel());
			result["neg"] <== aNeg;
			result["val"] <== owner.optimization.pipeline(reinterpretCast(sm.getOutput("r"), rValType));
			return result;
		}
	}
}
