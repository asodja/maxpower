package maxpower.kernel.merger.nodes;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import maxpower.kernel.merger.KMVar;
import maxpower.kernel.merger.Merger;
import maxpower.kernel.merger.utils.LatencyEstimation;
import maxpower.kernel.merger.utils.ResourceUsage;
import maxpower.kernel.pipeline.FanoutLimiter;

import com.maxeler.maxcompiler.v2.errors.MaxCompilerAPIError;
import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.KernelObjectVectorizable;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

public class KMNodeMux extends KMNode implements java.io.Serializable {

	private static final long serialVersionUID = 6133584634984691435L;

	List<Boolean> m_used = new ArrayList<Boolean>();
	Map<List<Set<Integer>>, FanoutLimiter<DFEVar>> m_kernelSelects =
		new HashMap<List<Set<Integer>>, FanoutLimiter<DFEVar>>();

	public KMNodeMux(KMVar select, List<KMVar> inputs) {
		super();
		m_inputs.add(select.getSource());
		for (KMVar in : inputs) {
			m_inputs.add(in.getSource());
		}
	}

	public KMNodeMux(KMNode select, List<KMNode> inputs) {
		super();
		m_inputs.add(select);
		for (KMNode input : inputs) {
			if (input == null) {
				m_used.add(false);
			} else {
				m_inputs.add(input);
				m_used.add(true);
			}
		}
	}

	@SuppressWarnings({ "rawtypes", "unchecked" })
	@Override
	public void execute(Merger merger) {
		KernelObjectVectorizable result;
		DFEVar muxSelect;
		List<KernelObjectVectorizable> muxInputs = new ArrayList<KernelObjectVectorizable>();

		if (isAutoGenerated() && m_used.size() + 1 != m_inputs.size()) {
			List<Set<Integer>> kernelSelectBlocks = new ArrayList<Set<Integer>>();
			List<KMNode> uniqueInputs = new ArrayList<KMNode>();

			int inputIndex = 1;
			for (int i = 0; i < m_used.size(); i++) {
				if (m_used[i]) {
					boolean found = false;
					for (int j = 0; j < uniqueInputs.size(); j++) {
						if (uniqueInputs[j] == m_inputs[inputIndex]) {
							kernelSelectBlocks[j].add(i);
							found = true;
						}
					}
					if (!found) {
						Set<Integer> hashSet = new HashSet<Integer>();
						hashSet.add(i);
						kernelSelectBlocks.add(hashSet);
						uniqueInputs.add(m_inputs[inputIndex]);
					}
					inputIndex++;
				}
			}

			if (shouldUseLookup(kernelSelectBlocks.size())) {
				if (uniqueInputs.size() > 1) {
					for (KMNode input : uniqueInputs) {
						muxInputs.add(input.getResult());
					}
					muxSelect = generateLookupTable(kernelSelectBlocks, merger);
					muxInputs = checkForAllUntyped(muxInputs);
					result = muxSelect.getKernel().control.mux(
							muxSelect.cast(Kernel.dfeUInt(MathUtils.bitsToAddress(muxInputs.size()))), muxInputs);
				} else {
					result = uniqueInputs[0].getResult();
				}
			} else {
				inputIndex = 1;
				for (int i = 0; i < m_used.size(); i++) {
					if (m_used[i] == false) {
						muxInputs.add(m_inputs[1].getResult());
					} else {
						muxInputs.add(m_inputs[inputIndex].getResult());
						inputIndex++;
					}
				}
				muxSelect = getMuxSelect();
				muxInputs = checkForAllUntyped(muxInputs);
				result = muxSelect.getKernel().control.mux(
						muxSelect.cast(Kernel.dfeUInt(MathUtils.bitsToAddress(muxInputs.size()))), muxInputs);
			}
		} else {
			for (int i = 1; i < m_inputs.size(); i++) {
				muxInputs.add(m_inputs[i].getResult());
			}
			muxSelect = getMuxSelect();
			muxInputs = checkForAllUntyped(muxInputs);
			result = muxSelect.getKernel().control.mux(
					muxSelect.cast(Kernel.dfeUInt(MathUtils.bitsToAddress(muxInputs.size()))), muxInputs);
		}

		m_result = new FanoutLimiter(result, merger.getMaxFanout());
	}

	/*
	 * If the node was auto generated it might not be used in every kernel.
	 * However our kernelSelect signal is always the same so in some cases we might want to use a lookup table to reduce
	 * the width of the mux.
	 * This function evaluates a heuristic to determine if it is useful to use a lookup table to get the mux select signal.
	 * For now we only try to half the number of inputs.
	 * At later stages it might also be useful to look at stuff like data width etc.
	 */
	private boolean shouldUseLookup(int newSize) {
		return newSize < (float) m_used.size() / 2;
	}

	// TODO: In many cases there might be cheaper ways to do this.
	// This is only a first implementation that should do all right in most cases
	private DFEVar generateLookupTable(List<Set<Integer>> kernelSelectBlocks, Merger merger) {
		FanoutLimiter<DFEVar> kernelSelect = m_kernelSelects.get(kernelSelectBlocks);
		if (kernelSelect == null) {
			DFEVar oldKernelSelect = getMuxSelect();
			List<DFEVar> muxInputs = new ArrayList<DFEVar>();
			for (int i = 0; i < m_used.size(); i++) {
				int connection = 0;
				for (int j = 0; j < kernelSelectBlocks.size(); j++) {
					if (kernelSelectBlocks[j].contains(i)) {
						connection = j;
					}
				}
				muxInputs.add(oldKernelSelect.getKernel().constant.var(
						Kernel.dfeUInt(MathUtils.bitsToAddress(kernelSelectBlocks.size())), connection));
			}

			kernelSelect = new FanoutLimiter<DFEVar>(oldKernelSelect.getKernel().control.mux(oldKernelSelect.cast(
					Kernel.dfeUInt(MathUtils.bitsToAddress(muxInputs.size()))), muxInputs), merger.getMaxFanout());
			m_kernelSelects.put(kernelSelectBlocks, kernelSelect);
		} else {
			getMuxSelect().setReportOnUnused(false);
		}
		return kernelSelect.get();
	}

	public boolean isAutoGenerated() {
		KMNode input = m_inputs[0];
		if (input instanceof KMNodeInput) {
			return ((KMNodeInput) input).getName().equals(Merger.KERNEL_MUX_SELECT_NAME);
		}
		return false;
	}

	@SuppressWarnings("rawtypes")
	private DFEVar getMuxSelect() {
		KernelObjectVectorizable kernelSelectSignal = m_inputs[0].getResult();
		if (!(kernelSelectSignal instanceof DFEVar)) {
			throw new MaxCompilerAPIError("Input to a Mux has to be a DFEVar");
		}
		return (DFEVar) kernelSelectSignal;
	}

	@SuppressWarnings({ "rawtypes", "unchecked" })
	private List<KernelObjectVectorizable> checkForAllUntyped(List<KernelObjectVectorizable> muxInputs) {
		boolean isAllUntyped = true;
		for (KernelObjectVectorizable input : muxInputs) {
			isAllUntyped &= !input.getType().isConcreteType();
		}

		if (isAllUntyped) {
			List<KernelObjectVectorizable> result = new ArrayList<KernelObjectVectorizable>();
			for (KernelObjectVectorizable input : muxInputs) {
				result.add((KernelObjectVectorizable) input.cast(m_resultType.getPrimitiveType()));
			}

			return result;
		} else {
			return muxInputs;
		}
	}

	@Override
	public String toString() {
		return "NodeMux: " + m_id;
	}

	@Override
	public void calcResultType(Merger merger) {
		for (int i = 1; i < m_inputs.size(); i++) {
			if (m_inputs[i].getResultType() != null) {
				m_resultType = m_inputs[i].getResultType();
				break;
			}
		}
	}

	@Override
	public ResourceUsage getResourceUsageEstimate(Merger merger) {
		ResourceUsage result = ResourceUsage.getMux(m_resultType.getPrimitiveType().getTotalBits());
		result *= m_resultType.getPrimitiveCount();
		return result * (m_inputs.size() - 1);
	}

	@Override
	int getLatencyEstimate(Merger merger) {
		return LatencyEstimation.getMux(merger);
	}

}
