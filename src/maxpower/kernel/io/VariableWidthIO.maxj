package maxpower.kernel.io;

import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.KernelObjectVectorizable;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.KernelType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

/**
 * Creates an input similar to {@link com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.IO IO}
 * with a variable number of inputs per cycle up to some build time maximum.
 *
 * @author David Packwood
 */
public class VariableWidthIO extends KernelLib {
	private final int maxWidth;
	private final DFEType doubleShiftType;

	/**
	 * Create an io port of a given maximum width so that a variable width input can be created.
	 * @param owner The Kernel or KernelLib the object is being used in.
	 * @param maxWidthIn The width of the input port (number of words).
	 */
	public VariableWidthIO(KernelLib owner, int maxWidthIn) {

		super (owner);
		maxWidth =  maxWidthIn;
		int shiftBits = MathUtils.bitsToRepresent(maxWidth - 1);
		doubleShiftType = dfeUInt(shiftBits + 1);
	}

	/**
	 * Create an input of a given maximum width which can return a variable number of valid data (up to the maximum width) each cycle from the input.
	 * @param name The name of the input as referenced in the manager
	 * @param inputType The type of the input data
	 * @param numToRead A stream giving the number of valid number of inputs needed on a given cycle (each value must be leq the maximum width for defined behaviour)
	 * @return A DFEVector of size maximum width, the first <code> needIn </code> elements of which are read linearly from the input.
	 */
	public <T extends KernelObjectVectorizable<T,?>> DFEVector<T> input(String name, KernelType<T> inputType, DFEVar numToRead) {
		optimization.pushPipeliningFactor(0);
		DFEVectorType<T> wideInputType = new DFEVectorType<T>(inputType, maxWidth);
		DFEVectorType<T> doubleWideInputType = new DFEVectorType<T>(inputType, maxWidth*2);

		DFEVar isFirstTick = control.count.pulse(1);
		DFEVar carried = doubleShiftType.newInstance(this);
		DFEVar used = isFirstTick ?  0 : carried;

		DFEVar need = numToRead.cast(doubleShiftType);

		DFEVar neededWidth = used + need;

		DFEVar needToGet = (neededWidth > maxWidth) | (used === 0);
		DFEVector<T> wideInput = io.input(name, wideInputType, needToGet);

		DFEVector<T> twoCycleInput = doubleWideInputType.newInstance(this);
		DFEVar inputFlipper = needToGet & carried.eq(0);
		for (int i = 0; i < maxWidth; i++) {
			twoCycleInput[i] <== inputFlipper ? wideInput[i] : stream.offset(wideInput, -1)[i];
			twoCycleInput[i + maxWidth] <== inputFlipper ? stream.offset(wideInput, -1)[i] : wideInput[i];
		}

		DFEVector<T> output = wideInputType.newInstance(this);
		DFEVector<T> twoCycleShifted = twoCycleInput.shiftElementsRight(used);
		for (int i = 0; i < maxWidth; i++) {
			output[i] <== twoCycleShifted[i];
		}

		DFEVar lastWidth = stream.offset(neededWidth, -1);
		carried <== (lastWidth < maxWidth) ?  lastWidth : lastWidth - maxWidth;

		optimization.popPipeliningFactor();
		return optimization.pipeline(output);
	}
}
