package maxpower.kernel.io;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import maxpower.kernel.pipeline.FanoutLimiter;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.Reductions;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.KernelObject;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.KernelObjectVectorizable;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;

public class ShiftRegister {
	private static final int DEFAULT_MAX_FANOUT = 1024;

	public static <T extends KernelObjectVectorizable<T, T>> DFEVector<T> serialToParallel(int n, T input) {
		Kernel owner = input.getKernel();
		return owner.stream.offset(serialToParallel(n, input, owner.constant.var(true), Integer.MAX_VALUE), +n-1);
	}

	public static <T extends KernelObjectVectorizable<T, T>>
		DFEVector<T> serialToParallel(int n, T input, DFEVar inputValid)
	{
		return serialToParallel(n, input, inputValid, DEFAULT_MAX_FANOUT);
	}

	public static <T extends KernelObjectVectorizable<T, T>>
		DFEVector<T> serialToParallel(int n, T input, DFEVar inputValid, int maxFanout)
	{
		Kernel owner = input.getKernel();

		List<T> output = new ArrayList<T>(n);

		FanoutLimiter<DFEVar> enable =
			new FanoutLimiter<DFEVar>(inputValid, maxFanout / input.getType().getTotalBits());

		output.add(Reductions.streamHold(input, enable.get()));
		for (int i = 1; i < n; ++i) {
			output.add(Reductions.streamHold(owner.stream.offset(output[i-1], -1), enable.get()));
		}

		// We want the earliest data to appear at index 0.
		Collections.reverse(output);
		return DFEVectorType.newInstance(output);
	}

	public static <T extends KernelObjectVectorizable<T, T>>
		T parallelToSerial(DFEVector<T> input, DFEVar inputValid)
	{
		return parallelToSerial(input.getElementsAsList(), inputValid);
	}

	public static <T extends KernelObject<T>> T parallelToSerial(List<T> input, DFEVar inputValid) {
		Kernel owner = input[0].getKernel();
		return parallelToSerial(input, inputValid, owner.constant.var(true), Integer.MAX_VALUE);
	}

	public static <T extends KernelObjectVectorizable<T, T>>
		T parallelToSerial(DFEVector<T> input, DFEVar inputValid, DFEVar shift)
	{
		return parallelToSerial(input.getElementsAsList(), inputValid, shift);
	}

	public static <T extends KernelObject<T>>
		T parallelToSerial(List<T> input, DFEVar inputValid, DFEVar shift)
	{
		return parallelToSerial(input, inputValid, shift, DEFAULT_MAX_FANOUT);
	}

	public static <T extends KernelObjectVectorizable<T, T>>
		T parallelToSerial(DFEVector<T> input, DFEVar inputValid, DFEVar shift, int maxFanout)
	{
		return parallelToSerial(input.getElementsAsList(), inputValid, shift, maxFanout);
	}

	public static <T extends KernelObject<T>>
		T parallelToSerial(List<T> input, DFEVar inputValid, DFEVar shift, int maxFanout)
	{
		Kernel owner = inputValid.getKernel();

		FanoutLimiter<DFEVar> enable =
			new FanoutLimiter<DFEVar>(inputValid | shift, maxFanout / input[0].getType().getTotalBits());

		int n = input.size();
		List<T> regs = new ArrayList<T>(n);
		regs.add(Reductions.streamHold(input[n-1], enable.get()));

		for (int i = 1; i < n; ++i) {
			regs.add(Reductions.streamHold(inputValid ? input[n-i-1] : owner.stream.offset(regs[i-1], -1), enable.get()));
		}

		return regs[n-1];
	}
}
