package maxpower.kernel.io;

import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.KernelObjectVectorizable;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.KernelType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

/**
*
*
* @author David Packwood
*
*  A class to provide an input similar to {@link com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.IO IO} with a variable number of inputs per cycle up to some build time maximum.
*/
public class FlexibleWidthInput extends KernelLib{

	int maxWidth;
	DFEType shiftType;
	DFEType doubleShiftType;

	/**
	 * Create an io port of a given maximum width so that a variable width input can be created.
	 * @param owner The Kernel or KernelLib the object is being used in.
	 * @param maxWidthIn The width of the input port (128,1536,3078)
	 */
	public FlexibleWidthInput(KernelLib owner, int maxWidthIn){

		super (owner);
		maxWidth =  maxWidthIn;
		shiftType = dfeUInt(MathUtils.bitsToRepresent(maxWidth));
		doubleShiftType = dfeUInt(MathUtils.bitsToRepresent(maxWidth)+1);

	}

	/**
	 * Create an input of a given maximum width which can return a variable number of valid data (up to the maximum width) each cycle from the input.
	 * @param <T> The type of the input (DFEVar, DFEVector...)
	 * @param name The name of the input as referenced in the manager
	 * @param inputType The type of the input data
	 * @param needIn A stream giving the number of valid number of inputs needed on a given cycle (each value must be leq the maximum width for defined behaviour)
	 * @return A DFEVector of size maximum width, the first <code> needIn </code> elements of which are read linearly from the input.
	 */
	public <T extends KernelObjectVectorizable<T,T>> DFEVector<T> input(String name, KernelType<T> inputType, DFEVar needIn) {

		optimization.pushPipeliningFactor(0);
		DFEVectorType<T> wideInputType = new DFEVectorType<T>(inputType,maxWidth);

		DFEVar isFirstTick = control.count.pulse(1);
		DFEVar carried = doubleShiftType.newInstance(this);
		DFEVar used = isFirstTick === 1? constant.zero(doubleShiftType) : carried;

		DFEVar need = needIn.cast(doubleShiftType);

		DFEVar neededWidth = used + need;

		DFEVar needToGet = neededWidth > maxWidth | used === 0 ? constant.var(true) : constant.var(false);
		DFEVector<T> wideInput = io.input(name, wideInputType, needToGet);

		DFEVector<T> shiftedInput = wideInput.rotateElementsRight(used.cast(shiftType));

		stream.suppressOffsetVectorWarnings();
		DFEVector<T> shiftedPreviousInput = stream.offset(wideInput, -1).rotateElementsRight(used.cast(shiftType));

		DFEVector<T> output = wideInputType.newInstance(this);
		for (int i = 0; i < maxWidth; i++){
			output.get(i) <== used + i >= maxWidth | used === 0 ? shiftedInput.get(i) : shiftedPreviousInput.get(i);
		}

		DFEVar lastWidth = stream.offset(neededWidth,-1);
		carried <== lastWidth < maxWidth ?  lastWidth : lastWidth - maxWidth;

		optimization.popPipeliningFactor();
		return output;
	}
}